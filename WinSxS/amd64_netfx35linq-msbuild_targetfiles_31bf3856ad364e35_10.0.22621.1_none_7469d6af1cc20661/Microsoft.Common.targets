<!--
***********************************************************************************************
Microsoft.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process for .NET projects.  It
contains all the steps that are common among the different .NET languages, such as
Visual Basic, C#, and Visual J#.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->

<Project DefaultTargets="Build" InitialTargets="_CheckForInvalidConfigurationAndPlatform" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

    <Import Project="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')"/>

    <PropertyGroup>
        <CustomBeforeMicrosoftCommonTargets Condition="'$(CustomBeforeMicrosoftCommonTargets)'==''">$(MSBuildExtensionsPath)\v3.5\Custom.Before.Microsoft.Common.targets</CustomBeforeMicrosoftCommonTargets>
        <CustomAfterMicrosoftCommonTargets Condition="'$(CustomAfterMicrosoftCommonTargets)'==''">$(MSBuildExtensionsPath)\v3.5\Custom.After.Microsoft.Common.targets</CustomAfterMicrosoftCommonTargets>
        <ReportingServicesTargets Condition="'$(ReportingServicesTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v9.0\ReportingServices\Microsoft.ReportingServices.targets</ReportingServicesTargets>
    </PropertyGroup>

    <Import Project="$(CustomBeforeMicrosoftCommonTargets)" Condition="Exists('$(CustomBeforeMicrosoftCommonTargets)')"/>

    <!--
    Several properties must be set in the main project file, before using this .TARGETS file.
    However, if the properties are not set, we pick some defaults.

    OutDir:
    Indicates the final output location for the project or solution. When building a solution,
    OutDir can be used to gather multiple project outputs in one location. In addition,
    OutDir is included in AssemblySearchPaths used for resolving references.

    OutputPath:
    This property is usually specified in the project file and is used to initialize OutDir.
    OutDir and OutputPath are distinguished for legacy reasons, and OutDir should be used if at all possible.

    BaseIntermediateOutputPath:
    This is the top level folder where all configuration specific intermediate output folders will be created.
    Default value is obj\

    IntermediateOutputPath:
    This is the full intermediate Output Path, and is derived from BaseIntermediateOutputPath, if none specified
    (eg. obj\debug). If this property is overridden, then setting BaseIntermediateOutputPath has no effect.
    -->

    <PropertyGroup>
        <!-- Ensure any OutputPath has a trailing slash, so it can be concatenated -->
        <OutputPath Condition="'$(OutputPath)' != '' and !HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
        <AssemblyName Condition=" '$(AssemblyName)'=='' ">$(MSBuildProjectName)</AssemblyName>
        <!--
        Be careful not to give OutputPath a default value in the case of an invalid Configuration/Platform.
        We use OutputPath specifically to check for invalid configurations/platforms.
        -->
        <OutputPath Condition=" '$(Platform)'=='' and '$(Configuration)'=='' and '$(OutputPath)'=='' ">bin\Debug\</OutputPath>
        <_OriginalConfiguration>$(Configuration)</_OriginalConfiguration>
        <_OriginalPlatform>$(Platform)</_OriginalPlatform>
        <Configuration Condition=" '$(Configuration)'=='' ">Debug</Configuration>
        <ConfigurationName Condition=" '$(ConfigurationName)' == '' ">$(Configuration)</ConfigurationName>      <!-- Example, Debug -->
        <Platform Condition=" '$(Platform)'=='' ">AnyCPU</Platform>

        <OutputType Condition=" '$(TargetType)' != ''">$(TargetType)</OutputType>
        <OutputType Condition=" '$(TargetType)' == 'Container' or '$(TargetType)' == 'DocumentContainer' ">library</OutputType>
        <OutputType Condition=" '$(OutputType)' == '' ">exe</OutputType>

        <DebugSymbols Condition=" '$(ConfigurationName)' == 'Debug' and '$(DebugSymbols)' == '' and '$(DebugType)'==''">true</DebugSymbols>

        <!-- Whether or not a .pdb file is produced. -->
        <_DebugSymbolsProduced>false</_DebugSymbolsProduced>
        <_DebugSymbolsProduced Condition="'$(DebugSymbols)'=='true'">true</_DebugSymbolsProduced>
        <_DebugSymbolsProduced Condition="'$(DebugType)'=='none'">false</_DebugSymbolsProduced>
        <_DebugSymbolsProduced Condition="'$(DebugType)'=='pdbonly'">true</_DebugSymbolsProduced>
        <_DebugSymbolsProduced Condition="'$(DebugType)'=='full'">true</_DebugSymbolsProduced>

        <!-- Whether or not a .xml file is produced. -->
        <_DocumentationFileProduced>true</_DocumentationFileProduced>
        <_DocumentationFileProduced Condition="'$(DocumentationFile)'==''">false</_DocumentationFileProduced>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(OutputPath)' == '' ">
        <!--
        A blank OutputPath at this point means that the user passed in an invalid Configuration/Platform
        combination.  Whether this is considered an error or a warning depends on the value of
        $(SkipInvalidConfigurations).
        -->
        <_InvalidConfigurationError Condition=" '$(SkipInvalidConfigurations)' != 'true' ">true</_InvalidConfigurationError>
        <_InvalidConfigurationWarning Condition=" '$(SkipInvalidConfigurations)' == 'true' ">true</_InvalidConfigurationWarning>
    </PropertyGroup>

    <!--
    IDE Macros available from both integrated builds and from command line builds.
    The following properties are 'macros' that are available via IDE for
    pre and post build steps.
    -->
    <PropertyGroup>
        <TargetExt Condition="'$(OutputType)'=='exe'">.exe</TargetExt>
        <TargetExt Condition="'$(OutputType)'=='winexe'">.exe</TargetExt>
        <TargetExt Condition="'$(OutputType)'=='library'">.dll</TargetExt>
        <TargetExt Condition="'$(OutputType)'=='module'">.netmodule</TargetExt>
    </PropertyGroup>

    <PropertyGroup>
        <OutDir Condition=" '$(OutDir)' == '' ">$(OutputPath)</OutDir>                                          <!-- Example, bin\Debug\ -->
        <!-- Ensure OutDir has a trailing slash, so it can be concatenated -->
        <OutDir Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')">$(OutDir)\</OutDir>
        <ProjectName Condition=" '$(ProjectName)' == '' ">$(MSBuildProjectName)</ProjectName>                   <!-- Example, MyProject -->
        <TargetName Condition=" '$(TargetName)' == '' ">$(AssemblyName)</TargetName>                            <!-- Example, MyAssembly -->
        <ProjectFileName Condition=" '$(ProjectFileName)' == '' ">$(MSBuildProjectFile)</ProjectFileName>       <!-- Example, MyProject.csproj -->
        <ProjectExt Condition=" '$(ProjectExt)' == '' ">$(MSBuildProjectExtension)</ProjectExt>                 <!-- Example, .csproj -->
        <TargetFileName Condition=" '$(TargetFileName)' == '' ">$(TargetName)$(TargetExt)</TargetFileName>      <!-- Example, MyAssembly.dll -->
    </PropertyGroup>

    <ItemGroup>
        <_DebugSymbolsIntermediatePath Include="$(IntermediateOutputPath)$(TargetName).pdb" Condition="'$(_DebugSymbolsProduced)'=='true' and '@(_DebugSymbolsIntermediatePath)'==''"/>
        <_DebugSymbolsOutputPath Include="@(_DebugSymbolsIntermediatePath->'$(OutDir)%(Filename)%(Extension)')" Condition="'$(_DebugSymbolsProduced)'=='true'"/>
    </ItemGroup>

    <PropertyGroup>
        <!--
        The PublishableProject property is used when invoking the publish target on a solution that
        contains multiple projects. The property determines which projects should be published, and
        which projects should be skipped in the publish target. By default any "Windows Application"
        or "Console Application" project type is publishable. However, a project that would otherwise
        be published can be skipped by defining the PublishableProject property in the project itself.
        -->
        <_DeploymentPublishableProjectDefault Condition="'$(OutputType)'=='winexe' or '$(OutputType)'=='exe'">true</_DeploymentPublishableProjectDefault>
        <PublishableProject Condition="'$(PublishableProject)'==''">$(_DeploymentPublishableProjectDefault)</PublishableProject>

        <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='library'">Native.$(AssemblyName).manifest</_DeploymentTargetApplicationManifestFileName> <!-- Example, Native.MyAssembly.manifest -->
        <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='winexe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>       <!-- Example, MyAssembly.exe.manifest -->
        <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='exe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>          <!-- Example, MyAssembly.exe.manifest -->
        <TargetDeployManifestFileName Condition="'$(TargetDeployManifestFileName)' == '' and '$(HostInBrowser)' != 'true'">$(AssemblyName).application</TargetDeployManifestFileName>  <!-- Example, MyAssembly.application -->
        <TargetDeployManifestFileName Condition="'$(TargetDeployManifestFileName)' == '' and '$(HostInBrowser)' == 'true'">$(AssemblyName).xbap</TargetDeployManifestFileName>  <!-- Example, MyAssembly.xbap -->
        <GenerateClickOnceManifests Condition="'$(OutputType)'=='winexe' or '$(OutputType)'=='exe'">$(GenerateManifests)</GenerateClickOnceManifests>

        <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='library'">Native.$(AssemblyName)</_DeploymentApplicationManifestIdentity>
        <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='winexe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
        <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='exe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
        <_DeploymentDeployManifestIdentity Condition="'$(HostInBrowser)' != 'true'">$(AssemblyName).application</_DeploymentDeployManifestIdentity>
        <_DeploymentDeployManifestIdentity Condition="'$(HostInBrowser)' == 'true'">$(AssemblyName).xbap</_DeploymentDeployManifestIdentity>

        <_DeploymentFileMappingExtension Condition="'$(MapFileExtensions)'=='true'">.deploy</_DeploymentFileMappingExtension>
        <_DeploymentFileMappingExtension Condition="'$(MapFileExtensions)'!='true'"></_DeploymentFileMappingExtension>

        <_DeploymentBuiltUpdateInterval Condition="'$(UpdatePeriodically)'=='true'">$(UpdateInterval)</_DeploymentBuiltUpdateInterval>
        <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'=='true'">$(UpdateIntervalUnits)</_DeploymentBuiltUpdateIntervalUnits>
        <_DeploymentBuiltUpdateInterval Condition="'$(UpdatePeriodically)'!='true'">0</_DeploymentBuiltUpdateInterval>
        <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'!='true'">Days</_DeploymentBuiltUpdateIntervalUnits>
        <_DeploymentBuiltMinimumRequiredVersion Condition="'$(UpdateRequired)'=='true'">$(MinimumRequiredVersion)</_DeploymentBuiltMinimumRequiredVersion>

        <MaxTargetPath Condition="'$(MaxTargetPath)'==''">100</MaxTargetPath>

        <_DeploymentSignClickOnceManifests Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(SignManifests)' == 'true'">true</_DeploymentSignClickOnceManifests>
    </PropertyGroup>

    <PropertyGroup>
        <!-- 
        By default, GenerateApplicationManifest puts all satellite assemblies to the manifest
        record by default by setting TargetCulture to *. 
        -->
        <TargetCulture Condition="'$(TargetCulture)'==''">*</TargetCulture>
        <FallbackCulture Condition="'$(UICulture)'!='' and '$(FallbackCulture)'==''">$(UICulture)</FallbackCulture>
    </PropertyGroup>

    <ItemGroup>
        <!-- Create the output path as an item so that we can use %(FullPath) on it. -->
        <_OutputPathItem Include="$(OutDir)"/>
        <_UnmanagedRegistrationCache Include="$(BaseIntermediateOutputPath)$(MSBuildProjectFile).UnmanagedRegistration.cache"/>
        <_ResolveComReferenceCache Include="$(IntermediateOutputPath)$(MSBuildProjectFile).ResolveComReference.cache"/>
    </ItemGroup>

    <PropertyGroup>
        <!-- Example, c:\MyProjects\MyProject\bin\debug\ -->
        <!--
        Condition intentionally omitted on this one, because it causes problems
        when we pick up the value of an environment variable named TargetDir
        -->
        <TargetDir>@(_OutputPathItem->'%(FullPath)')</TargetDir>

        <!-- Example, c:\MyProjects\MyProject\bin\debug\MyAssembly.dll -->
        <TargetPath Condition=" '$(TargetPath)' == '' ">@(_OutputPathItem->'%(FullPath)$(TargetFileName)')</TargetPath>

        <!-- Example, c:\MyProjects\MyProject\ -->
        <ProjectDir Condition=" '$(ProjectDir)' == '' ">$(MSBuildProjectDirectory)\</ProjectDir>

        <!-- Example, c:\MyProjects\MyProject\MyProject.csproj -->
        <ProjectPath Condition=" '$(ProjectPath)' == '' ">$(ProjectDir)$(ProjectFileName)</ProjectPath>

        <!-- Example, AnyCPU -->
         <PlatformName Condition=" '$(PlatformName)' == '' ">$(Platform)</PlatformName>
    </PropertyGroup>

    <ItemGroup>
        <!-- This is not used here but remains for backwards compatibility -->
        <AppConfigFileDestination Include="$(OutDir)$(TargetFileName).config"/>
    </ItemGroup>

    <PropertyGroup>
        <LoadTimeSensitiveTargets>
            $(LoadTimeSensitiveTargets);
            Compile;
            ResolveReferences;
            BeforeResolveReferences;
            SplitProjectReferencesByType;
            ResolveProjectReferences;
            ResolveVCProjectReferences;
            ResolveNativeReferences;
            ResolveAssemblyReferences;
            GetFrameworkPaths;
            GetReferenceAssemblyPaths;
            PrepareForBuild;
            ResolveComReferences;
            ResolveKeySource;
            AfterResolveReferences;
            BeforeCompile;
            CoreCompile;
            AfterCompile;
            AllProjectOutputGroupsDependencies;
            BuildOnlySettings;
            AssignTargetPaths;
            BuiltProjectOutputGroupDependencies;
            DebugSymbolsProjectOutputGroupDependencies;
            SatelliteDllsProjectOutputGroupDependencies;
            DocumentationProjectOutputGroupDependencies;
            SGenFilesOutputGroupDependencies;
            AllProjectOutputGroups;
            BuiltProjectOutputGroup;
            DebugSymbolsProjectOutputGroup;
            DocumentationProjectOutputGroup;
            SatelliteDllsProjectOutputGroup;
            PrepareResourceNames;
            SplitResourcesByCulture;
            CreateManifestResourceNames;
            SourceFilesProjectOutputGroup;
            ContentFilesProjectOutputGroup;
            SGenFilesOutputGroup;
            CopyRunEnvironmentFiles;
            GetTargetPath;
            SetWin32ManifestProperties;
            CreateCustomManifestResourceNames
        </LoadTimeSensitiveTargets>
        <LoadTimeSensitiveProperties>
            $(LoadTimeSensitiveProperties);
            MSBuildProjectFullPath;
            CustomBeforeMicrosoftCommonTargets;
            MSBuildExtensionsPath;
            CodeAnalysisTargets;
            MSBuildExtensionsPath32;
            ReportingServicesTargets;
            MsTestToolsTargets;
            CustomAfterMicrosoftCommonTargets;
            CompileDependsOn;
            ResolveReferencesDependsOn;
            ResolveAssemblyReferencesDependsOn;
            GetFrameworkPathsDependsOn;
            GetReferenceAssemblyPathsDependsOn;
            PrepareForBuildDependsOn;
            CoreCompileDependsOn;
            PrepareResourceNamesDependsOn;
            CreateManifestResourceNamesDependsOn;
            BuildingProject;
            BuildingInsideVisualStudio;
            ResolveAssemblyReferencesStateFile;
            CleanFile;
            MSBuildProjectFile;
            BaseIntermediateOutputPath;
            BuiltProjectOutputGroupDependsOn;
            DebugSymbolsProjectOutputGroupDependsOn;
            DocumentationProjectOutputGroupDependsOn;
            SatelliteDllsProjectOutputGroupDependsOn;
            PrepareResourceNamesDependsOn;
            CreateManifestResourceNamesDependsOn;
            SourceFilesProjectOutputGroupDependsOn;
            ContentFilesProjectOutputGroupDependsOn;
            SGenFilesOutputGroupDependsOn;
            AssignTargetPathsDependsOn;
            CreateCustomManifestResourceNamesDependsOn;
        </LoadTimeSensitiveProperties>
        <LoadTimeSensitiveItems>
            $(LoadTimeSensitiveItems);
            AppConfigWithTargetPath;
            AppConfigFileDestination;
        </LoadTimeSensitiveItems>
        <LoadTimeCheckItemLocation>
            $(LoadTimeCheckItemLocation);
            AppConfigFileDestination;
        </LoadTimeCheckItemLocation>
    </PropertyGroup>

    <!--
    IDE Macros available only from integrated builds.
    The following properties are 'macros' that are available via IDE for
    pre and post build steps. However, they are not defined when directly building
    a project from the command line, only when building a solution.
    -->
    <PropertyGroup>
        <DevEnvDir Condition="'$(DevEnvDir)'==''">*Undefined*</DevEnvDir>
        <SolutionName Condition="'$(SolutionName)'==''">*Undefined*</SolutionName>              <!-- Example, MySolution -->
        <SolutionFileName Condition="'$(SolutionFileName)'==''">*Undefined*</SolutionFileName>  <!-- Example, MySolution.sln -->
        <SolutionPath Condition="'$(SolutionPath)'==''">*Undefined*</SolutionPath>              <!-- Example, f:\MySolutions\MySolution\MySolution.sln -->
        <SolutionDir Condition="'$(SolutionDir)'==''">*Undefined*</SolutionDir>                 <!-- Example, f:\MySolutions\MySolution\ -->
        <SolutionExt Condition="'$(SolutionExt)'==''">*Undefined*</SolutionExt>                 <!-- Example, .sln -->
    </PropertyGroup>

    <PropertyGroup>
        <AutoUnifyAssemblyReferences>true</AutoUnifyAssemblyReferences>
        <AutoUnifyAssemblyReferences Condition="'$(OutputType)'=='exe'">false</AutoUnifyAssemblyReferences>
        <AutoUnifyAssemblyReferences Condition="'$(OutputType)'=='winexe'">false</AutoUnifyAssemblyReferences>
        <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)'=='' ">obj\</BaseIntermediateOutputPath>
        <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
        <CleanFile Condition="'$(CleanFile)'==''">$(MSBuildProjectFile).FileListAbsolute.txt</CleanFile>
        <!-- By default we will build (and if applicable, clean) all project references. But this can be used to disable that-->
        <BuildProjectReferences Condition="'$(BuildProjectReferences)' == ''">true</BuildProjectReferences>
        <BuildInParallel Condition="'$(BuildInParallel)' == ''">true</BuildInParallel>
        <UnloadProjectsOnCompletion Condition="'$(UnloadProjectsOnCompletion)' == ''">false</UnloadProjectsOnCompletion>
        <_ResolveReferenceDependencies Condition="'$(_ResolveReferenceDependencies)' == ''">true</_ResolveReferenceDependencies>
        <_GetChildProjectCopyToOutputDirectoryItems Condition="'$(_GetChildProjectCopyToOutputDirectoryItems)' == ''">true</_GetChildProjectCopyToOutputDirectoryItems>
        <OverwriteReadOnlyFiles Condition="'$(OverwriteReadOnlyFiles)' == ''">false</OverwriteReadOnlyFiles>
        <ComReferenceNoClassMembers Condition="'$(ComReferenceNoClassMembers)' == ''">false</ComReferenceNoClassMembers>
    </PropertyGroup>

    <PropertyGroup Condition=" $(IntermediateOutputPath) == '' ">
        <IntermediateOutputPath Condition=" '$(PlatformName)' == 'AnyCPU' ">$(BaseIntermediateOutputPath)$(Configuration)\</IntermediateOutputPath>
        <IntermediateOutputPath Condition=" '$(PlatformName)' != 'AnyCPU' ">$(BaseIntermediateOutputPath)$(PlatformName)\$(Configuration)\</IntermediateOutputPath>
    </PropertyGroup>
    <PropertyGroup>
        <IntermediateOutputPath Condition="!HasTrailingSlash('$(IntermediateOutputPath)')">$(IntermediateOutputPath)\</IntermediateOutputPath>
    </PropertyGroup>
    <ItemGroup>
        <IntermediateAssembly Include="$(IntermediateOutputPath)$(TargetName)$(TargetExt)"/>
        <FinalDocFile Include="@(DocFileItem->'$(OutDir)%(Filename)%(Extension)')"/>
    </ItemGroup>

    <ItemGroup>
        <!-- Create an item for entry point of the ClickOnce application (Example: WindowsApplication1.exe) -->
        <_DeploymentManifestEntryPoint Include="@(IntermediateAssembly)">
            <TargetPath>$(TargetFileName)</TargetPath>
        </_DeploymentManifestEntryPoint>

        <!-- Create an item for the application icon if one exists in the project (Example: app.ico) -->
        <_DeploymentManifestIconFile Include="$(ApplicationIcon)" Condition="Exists('$(ApplicationIcon)')">
            <TargetPath>$(ApplicationIcon)</TargetPath>
        </_DeploymentManifestIconFile>

        <!-- Create an item for the output application manifest (Example: WindowsApplication1.exe.manifeset) -->
        <ApplicationManifest Include="$(IntermediateOutputPath)$(_DeploymentTargetApplicationManifestFileName)">
            <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
        </ApplicationManifest>

        <!-- Create an item for the final application manifest (Example: WindowsApplication1.exe.manifeset)
             This item represents the final output application manifest used for project-to-project
             references and for copying to the publish output location. -->
        <_ApplicationManifestFinal Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)">
            <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
        </_ApplicationManifestFinal>

        <!-- Create an item for the output deploy manifest (Example: WindowsApplication1.application) -->
        <DeployManifest Include="$(IntermediateOutputPath)$(TargetDeployManifestFileName)">
            <TargetPath>$(TargetDeployManifestFileName)</TargetPath>
        </DeployManifest>

        <!-- Create an item for the intermediate trust info file -->
        <_DeploymentIntermediateTrustInfoFile Include="$(IntermediateOutputPath)$(TargetName).TrustInfo.xml" Condition="'$(TargetZone)'!=''"/>
    </ItemGroup>

    <!--
    Determine the <deploymentProvider> (_DeploymentUrl) for the ClickOnce deployment manifest.
    Prefer the UpdateUrl, falling back to InstallUrl or PublishUrl if not specified.
    If the UpdateUrl is specified then _DeploymentUrl is always set to the UpdateUrl.
    Otherwise, only set the _DeploymentUrl if it's an installed app and updates are enabled.
    -->
    <PropertyGroup>
        <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(UpdateUrl)</_DeploymentUrl>
        <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(InstallUrl)</_DeploymentUrl>
        <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(PublishUrl)</_DeploymentUrl>
        <_DeploymentUrl Condition="'$(_DeploymentUrl)'!=''">$(_DeploymentUrl)$(TargetDeployManifestFileName)</_DeploymentUrl>
        <!--
        Need to explicitly blank out the _DeploymentUrl when it's not used. Otherwise an
        inappropriate value may be used. For example a local path from the PublishUrl
        is something we never want to see in the manifest because it means you could
        only install the app from that machine.
        -->
        <_DeploymentUrl Condition="'$(UpdateUrl)'=='' and !('$(Install)'=='true' and '$(UpdateEnabled)'=='true')"></_DeploymentUrl>
        <_DeploymentUrl Condition="'$(ExcludeDeploymentUrl)'=='true'"></_DeploymentUrl>
    </PropertyGroup>

    <!-- Determine the URLs for the bootstrapper. -->
    <PropertyGroup>
        <_DeploymentApplicationUrl Condition="'$(IsWebBootstrapper)'=='true'">$(InstallUrl)</_DeploymentApplicationUrl>
        <_DeploymentApplicationUrl Condition="'$(IsWebBootstrapper)'=='true' and '$(InstallUrl)'==''">$(PublishUrl)</_DeploymentApplicationUrl>
        <_DeploymentComponentsUrl Condition="'$(BootstrapperComponentsLocation)'=='Absolute'">$(BootstrapperComponentsUrl)</_DeploymentComponentsUrl>
    </PropertyGroup>

    <!-- Output location for publish target. -->
    <PropertyGroup>
        <PublishDir Condition="'$(PublishDir)' != '' and !HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
        <PublishDir Condition="'$(PublishDir)'==''">$(OutputPath)app.publish\</PublishDir>
    </PropertyGroup>

    <!--
    ProcessorArchitecture is the target processor architecture.
    -->
    <PropertyGroup Condition="'$(ProcessorArchitecture)'==''">
        <!--
        If ProcessorArchitecture is not set, set it to PlatformTarget
        Note: if $(PlatformTarget) is also blank resolve assembly reference defaults to msil which is the
        desired behavior in this case
        -->
        <ProcessorArchitecture>$(PlatformTarget)</ProcessorArchitecture>

        <!--
        If Processor architecture is not set and PlatformTarget is a known target translate the
        PlatformTarget into something ResolveAssemblyReference knows about
        -->
        <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'AnyCpu' ">msil</ProcessorArchitecture>
        <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'x64' ">amd64</ProcessorArchitecture>
        <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'Itanium' ">ia64</ProcessorArchitecture>
        <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'x86' ">x86</ProcessorArchitecture>
    </PropertyGroup>

    <!-- AvailablePlatforms is the list of platform targets available. -->
    <PropertyGroup>
        <AvailablePlatforms>Any CPU,x86,x64,Itanium</AvailablePlatforms>
    </PropertyGroup>

    <!-- Flavor is the project flavor. For example, Client, Smart Devices, SQL Server, etc. -->
    <PropertyGroup>
        <ProjectFlavor Condition="'$(ProjectFlavor)'==''">Client</ProjectFlavor>
    </PropertyGroup>

    <!--
    The default for compilers is to not delay-sign. If $(DelaySign) is false, let the compiler
    use its default rather than forcing a no-delay-sign flag to be passed in. This is so that
    attributes in the source code can override this decision.
    -->
    <PropertyGroup>
      <DelaySign Condition="'$(SignAssembly)' != 'true'">false</DelaySign>
      <DelaySign Condition="'$(DelaySign)'!='true'"></DelaySign>
    </PropertyGroup>

    <!-- These properties control web reference proxy generation. -->
    <PropertyGroup>
        <WebReference_EnableProperties Condition=" '$(WebReference_EnableProperties)' == '' ">true</WebReference_EnableProperties>
        <WebReference_EnableSQLTypes Condition=" '$(WebReference_EnableSQLTypes)' == '' ">true</WebReference_EnableSQLTypes>
        <WebReference_EnableLegacyEventingModel Condition=" '$(WebReference_EnableLegacyEventingModel)' == '' ">false</WebReference_EnableLegacyEventingModel>
    </PropertyGroup>

    <PropertyGroup>
        <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildProjectFullPath);$(MSBuildToolsPath)\Microsoft.Common.targets</MSBuildAllProjects>
        <MSBuildAllProjects Condition="Exists('$(MSBuildProjectFullPath).user')">$(MSBuildAllProjects);$(MSBuildProjectFullPath).user</MSBuildAllProjects>
    </PropertyGroup>

    <!--
    These parameters control where to look in the registry for directories to search for
    assemblies in the assembly resolution tasks.
    -->
    <PropertyGroup>
        <FrameworkRegistryBase Condition=" '$(FrameworkRegistryBase)' == '' ">Software\Microsoft\.NetFramework</FrameworkRegistryBase>
        <TargetFrameworkVersion Condition=" '$(TargetFrameworkVersion)' == '' ">v2.0</TargetFrameworkVersion>
        <AssemblyFoldersSuffix Condition=" '$(AssemblyFoldersSuffix)' == '' ">AssemblyFoldersEx</AssemblyFoldersSuffix>
    </PropertyGroup>

    <PropertyGroup>
        <!--
        The SearchPaths property is set to find assemblies in the following order:

            (1) Files from current project - indicated by {CandidateAssemblyFiles}
            (2) $(ReferencePath) - the reference path property, which comes from the .USER file.
            (3) The hintpath from the referenced item itself, indicated by {HintPathFromItem}.
            (4) The directory of MSBuild's "target" runtime from GetFrameworkPath.
                The "target" runtime folder is the folder of the runtime that MSBuild is a part of.
            (5) Registered assembly folders, indicated by {Registry:*,*,*}
            (6) Legacy registered assembly folders, indicated by {AssemblyFolders}
            (7) Look in the application's output folder (like bin\debug)
            (8) Resolve to the GAC.
            (9) Treat the reference's Include as if it were a real file name.
        -->
        <AssemblySearchPaths Condition=" '$(AssemblySearchPaths)' == '' ">
            {CandidateAssemblyFiles};
            $(ReferencePath);
            {HintPathFromItem};
            {TargetFrameworkDirectory};
            {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
            {AssemblyFolders};
            {GAC};
            {RawFileName};
            $(OutDir)
        </AssemblySearchPaths>

        <!--
        These are the extensions that assembly reference resolution will consider for resolution.
        Add new extensions here if you want to add new file types to consider (for example, .metadata_dll)
        -->
        <AllowedReferenceAssemblyFileExtensions Condition=" '$(AllowedReferenceAssemblyFileExtensions)' == '' ">
            .exe;
            .dll
        </AllowedReferenceAssemblyFileExtensions>

        <!--
        These are the extensions that reference resolution will consider when looking for files related
        to resolved references.  Add new extensions here if you want to add new file types to consider.
        -->
        <AllowedReferenceRelatedFileExtensions Condition=" '$(AllowedReferenceRelatedFileExtensions)' == '' ">
            .pdb;
            .xml
        </AllowedReferenceRelatedFileExtensions>

        <!--
        These names are used when determining which TargetFramework subset to use. If the any of the FullReferenceAssemblyNames 
        are seen in the list of client subsets, RAR will assume that no client subset is being used. The list is semicolon seperated
        For example :   Full;Complete;AllThere
        -->
        <FullReferenceAssemblyNames Condition="'$(FullReferenceAssemblyNames)' == ''">Full</FullReferenceAssemblyNames>
    </PropertyGroup>

    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Build Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        _CheckForInvalidConfigurationAndPlatform

    This target checks for errors in statically defined properties.  It always
    gets executed before any other target.
    ============================================================
    -->
    <Target
        Name="_CheckForInvalidConfigurationAndPlatform">

        <Error Condition=" '$(_InvalidConfigurationError)' == 'true' " Text="The OutputPath property is not set for this project.  Please check to make sure that you have specified a valid Configuration/Platform combination.  Configuration='$(_OriginalConfiguration)'  Platform='$(_OriginalPlatform)'"/>
        <Warning Condition=" '$(_InvalidConfigurationWarning)' == 'true' " Text="The OutputPath property is not set for this project.  Please check to make sure that you have specified a valid Configuration/Platform combination.  Configuration='$(_OriginalConfiguration)'  Platform='$(_OriginalPlatform)'"/>

        <Message Text="Configuration=$(Configuration)" Importance="Low" />
        <Message Text="Platform=$(Platform)" Importance="Low" />

        <!-- Although we try to ensure a trailing slash, it's possible to circumvent this if the property is set on the command line -->
        <Error Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')" Text="The OutDir property must end with a trailing slash." />
        <Error Condition="'$(BaseIntermediateOutputPath)' != '' and !HasTrailingSlash('$(BaseIntermediateOutputPath)')" Text="The BaseIntermediateOutputPath must end with a trailing slash." />
        <Error Condition="'$(IntermediateOutputPath)' != '' and !HasTrailingSlash('$(IntermediateOutputPath)')" Text="The IntermediateOutputPath must end with a trailing slash." />
    </Target>

    <!--
    ============================================================
                                        Build

    The main build entry point.
    ============================================================
    -->
    <PropertyGroup>
        <BuildDependsOn>
            BeforeBuild;
            CoreBuild;
            AfterBuild
        </BuildDependsOn>
    </PropertyGroup>
    <Target
        Name="Build"
        Condition=" '$(_InvalidConfigurationWarning)' != 'true' "
        DependsOnTargets="$(BuildDependsOn)"
        Outputs="$(TargetPath)"/>

    <!--
    ============================================================
                                        BeforeBuild

    Redefine this target in your project in order to run tasks just before Build
    ============================================================
    -->
    <Target Name="BeforeBuild"/>

    <!--
    ============================================================
                                        AfterBuild

    Redefine this target in your project in order to run tasks just after Build
    ============================================================
    -->
    <Target Name="AfterBuild"/>

    <!--
    ============================================================
                                        CoreBuild

    The core build step calls each of the build targets.
    ============================================================
    -->
    <PropertyGroup>
        <CoreBuildDependsOn>
              BuildOnlySettings;
              PrepareForBuild;
              PreBuildEvent;
              ResolveReferences;
              PrepareResources;
              ResolveKeySource;
              Compile;
              UnmanagedUnregistration;
              GenerateSerializationAssemblies;
              CreateSatelliteAssemblies;
              GenerateManifests;
              GetTargetPath;
              PrepareForRun;
              UnmanagedRegistration;
              IncrementalClean;
              PostBuildEvent
        </CoreBuildDependsOn>
    </PropertyGroup>
    <Target
        Name="CoreBuild"
        DependsOnTargets="$(CoreBuildDependsOn)">

        <!-- If the project maybe unloaded we need to cache the results of all external entry points. Most
             of these targets don't do actual work but we need to make sure that the result of the targets is
             in the cache.
        -->
        <CallTarget Targets="GetCopyToOutputDirectoryItems" UseResultsCache="true" Condition="'$(UnloadProjectsOnCompletion)'=='true'" />
        <CallTarget Targets="GetNativeManifest" UseResultsCache="true" Condition="'$(UnloadProjectsOnCompletion)'=='true'"/>
        <CallTarget Targets="GetTargetPath" UseResultsCache="true" Condition="'$(UnloadProjectsOnCompletion)'=='true'"/>

        <OnError ExecuteTargets="_TimeStampAfterCompile;PostBuildEvent" Condition="'$(RunPostBuildEvent)'=='Always' or '$(RunPostBuildEvent)'=='OnOutputUpdated'"/>
        <OnError ExecuteTargets="_CleanRecordFileWrites"/>

    </Target>

    <!--
    ============================================================
                                        Rebuild

    Delete all intermediate and final build outputs, and then build the project from scratch.
    ============================================================
    -->
    <PropertyGroup>
        <RebuildDependsOn>
            BeforeRebuild;
            Clean;
            $(MSBuildProjectDefaultTargets);
            AfterRebuild;
        </RebuildDependsOn>

        <RebuildDependsOn Condition=" '$(MSBuildProjectDefaultTargets)' == 'Rebuild' " >
            BeforeRebuild;
            Clean;
            Build;
            AfterRebuild;
        </RebuildDependsOn>
    </PropertyGroup>

    <Target
        Name="Rebuild"
        Condition=" '$(_InvalidConfigurationWarning)' != 'true' "
        DependsOnTargets="$(RebuildDependsOn)"
        Outputs="$(TargetPath)"/>

    <!--
    ============================================================
                                        BeforeRebuild

    Redefine this target in your project in order to run tasks just before Rebuild
    ============================================================
    -->
    <Target Name="BeforeRebuild"/>

    <!--
    ============================================================
                                        AfterRebuild

    Redefine this target in your project in order to run tasks just after Rebuild
    ============================================================
    -->
    <Target Name="AfterRebuild"/>

    <!--
    ============================================================
                                        CopyRunEnvironmentFiles

    Copy environment files necessary to run the user's app to the final directory.
    This is a public target that can be invoked by an IDE.

    This may be used by an IDE to make the app.config file available for running
    the target app.
    ============================================================
    -->
    <Target
        Name="CopyRunEnvironmentFiles"
        DependsOnTargets="PrepareForBuild;SetWin32ManifestProperties;_CopyAppConfigFile;_CleanRecordFileWrites"/>

    <!--
    ============================================================
                                        Run

    Run the final build output if it is a .EXE
    ============================================================
    -->
    <PropertyGroup>
        <RunDependsOn></RunDependsOn>
    </PropertyGroup>
    <Target
        Name="Run"
        DependsOnTargets="$(RunDependsOn)">

        <Error Text="Cannot run '$(TargetPath)' because project output type is not '.exe'" Condition="'$(TargetExt)'!='.exe'"/>
        <Exec Command="$(TargetPath) $(StartArguments)" WorkingDirectory="$(OutDir)" Condition=" '$(StartWorkingDirectory)' == '' "/>
        <Exec Command="$(TargetPath) $(StartArguments)" WorkingDirectory="$(StartWorkingDirectory)" Condition=" '$(StartWorkingDirectory)' != '' "/>

    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                BuildOnlySettings Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        BuildOnlySettings

    This target is called only when doing a real build.  It is specifically not called during project load.
    ============================================================
    -->
    <PropertyGroup>
        <BuildingProject>false</BuildingProject>
    </PropertyGroup>
    <Target
        Name="BuildOnlySettings">
        <PropertyGroup>
            <BuildingProject>true</BuildingProject>
        </PropertyGroup>
    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareForBuild Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        PrepareForBuild

    Prepare the prerequisites for building.
    ============================================================
    -->
    <PropertyGroup>
        <PrepareForBuildDependsOn>GetFrameworkPaths</PrepareForBuildDependsOn>
    </PropertyGroup>
    <Target
        Name="PrepareForBuild"
        DependsOnTargets="$(PrepareForBuildDependsOn)">

        <!--
        These PropertyGroups are required because TargetDir and TargetPath are defined
        to contain an item list. We want that item list to be expanded so that it can be used
        as a regular property value and not as an item-list-with-transform.
        -->
        <PropertyGroup>
            <TargetDir>$(TargetDir)</TargetDir>
            <TargetPath>$(TargetPath)</TargetPath>
        </PropertyGroup>

        <ItemGroup>
            <AppConfigWithTargetPath Include="$(AppConfig)" Condition="'$(AppConfig)'!=''">
                <TargetPath>$(TargetFileName).config</TargetPath>
            </AppConfigWithTargetPath>
        </ItemGroup>

        <FindAppConfigFile PrimaryList="@(None)" SecondaryList="@(Content)" TargetPath="$(TargetFileName).config" Condition="'$(AppConfig)'==''">
            <Output TaskParameter="AppConfigFile" ItemName="AppConfigWithTargetPath"/>
            <Output TaskParameter="AppConfigFile" PropertyName="AppConfig"/>
        </FindAppConfigFile>

        <!-- Create the directories for intermediate and final build products, and any other arbitrary directories. -->
        <MakeDir Directories="$(OutDir);$(IntermediateOutputPath);@(DocFileItem->'%(RelativeDir)');@(CreateDirectory)"/>      

    </Target>

    <!--
    ============================================================
                                        GetFrameworkPaths

    Get the paths for the .NET Framework installation directory, and the .NET Framework
    SDK installation directory.

    These paths are not used directly by this .targets file but are available for pre and
    post build steps.
    ============================================================
    -->
    <PropertyGroup>
        <Framework35Dir>@(_TargetFramework35DirectoryItem)</Framework35Dir>
        <Framework30Dir>@(_TargetFramework30DirectoryItem)</Framework30Dir>
        <Framework20Dir>@(_TargetFramework20DirectoryItem)</Framework20Dir>
        <FrameworkDir>@(_TargetFramework20DirectoryItem)</FrameworkDir>

        <FrameworkSDKDir>@(_TargetFrameworkSDKDirectoryItem)</FrameworkSDKDir>
        <GetFrameworkPathsDependsOn></GetFrameworkPathsDependsOn>
    </PropertyGroup>
    <Target
        Name="GetFrameworkPaths"
        DependsOnTargets="$(GetFrameworkPathsDependsOn)">

        <!-- Get the paths to all of the target .NET framework directories. -->
        <GetFrameworkPath>
            <Output Condition=" '$(TargetFrameworkVersion)' == 'v3.5' "                                                                                  TaskParameter="FrameworkVersion35Path"  ItemName="_CombinedTargetFrameworkDirectoriesItem" />
            <Output Condition=" '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5' "                                         TaskParameter="FrameworkVersion30Path"  ItemName="_CombinedTargetFrameworkDirectoriesItem" />
            <Output Condition=" '$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'" TaskParameter="FrameworkVersion20Path"  ItemName="_CombinedTargetFrameworkDirectoriesItem" />
            <Output TaskParameter="FrameworkVersion35Path"  ItemName="_TargetFramework35DirectoryItem" />
            <Output TaskParameter="FrameworkVersion30Path"  ItemName="_TargetFramework30DirectoryItem" />
            <Output TaskParameter="FrameworkVersion20Path"  ItemName="_TargetFramework20DirectoryItem" />
        </GetFrameworkPath>

        <PropertyGroup>
            <TargetFrameworkDirectory>@(_CombinedTargetFrameworkDirectoriesItem)</TargetFrameworkDirectory>
        </PropertyGroup>

        <!-- Get the path to the target .NET framework SDK directory. -->
        <GetFrameworkSdkPath>
            <Output TaskParameter="FrameworkSdkVersion35Path" PropertyName="TargetFrameworkSDKDirectory"/>
            <Output TaskParameter="FrameworkSdkVersion35Path" ItemName="_TargetFrameworkSDKDirectoryItem"/>
        </GetFrameworkSdkPath>

    </Target>

   <!--
    ============================================================
                                        GetReferenceAssemblyPaths

    Get the paths for the Reference Assemblies for the known versions of the
    .NET Framework.

    These paths are used by the build process in order to resolve the correct
    assemblies from the various directories, and to support multi-targeting
    ============================================================
    -->
    <PropertyGroup>
        <GetReferenceAssemblyPathsDependsOn></GetReferenceAssemblyPathsDependsOn>
    </PropertyGroup>
    <Target
        Name="GetReferenceAssemblyPaths"
        DependsOnTargets="$(GetReferenceAssemblyPathsDependsOn)">
        
        <!-- Ordering of target framework directories doesn't matter except for assemblies
             that aren't in a redist list; for those, make sure we order 3.5, 3.0, 2.0 -->

        <PropertyGroup Condition=" '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5' ">        
            <TargetFrameworkDirectory>$(WinFXAssemblyDirectory);$(TargetFrameworkDirectory)</TargetFrameworkDirectory>
        </PropertyGroup>
                
        <PropertyGroup Condition=" '$(TargetFrameworkVersion)' == 'v3.5' ">        
            <TargetFrameworkDirectory>$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\.NETFramework\AssemblyFolders\v3.5@All Assemblies In);$(TargetFrameworkDirectory)</TargetFrameworkDirectory>
        </PropertyGroup>
                
    </Target>


    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PreBuildEvent Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        PreBuildEvent

    Run the pre-build event if there is one.
    ============================================================
    -->
    <PropertyGroup>
        <PreBuildEventDependsOn></PreBuildEventDependsOn>
    </PropertyGroup>
    <Target
        Name="PreBuildEvent"
        Condition="'$(PreBuildEvent)'!=''"
        DependsOnTargets="$(PreBuildEventDependsOn)">

        <Exec WorkingDirectory="$(OutDir)" Command="$(PreBuildEvent)" />

    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                UnmanagedUnregistration Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        UnmanagedUnregistration

    If the main assembly had previously been registered for COM interop, unregister it now.
    We will re-register the new version after it has been built.
    ============================================================
    -->
    <PropertyGroup>
        <UnmanagedUnregistrationDependsOn></UnmanagedUnregistrationDependsOn>
    </PropertyGroup>
    <Target
        Name="UnmanagedUnregistration"
        Condition="(('$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)' or '$(RegisterForComInterop)' != 'true' or '$(OutputType)' != 'library') or
                    ('$(_AssemblyTimestampBeforeCompile)' == '')) and
                   Exists('@(_UnmanagedRegistrationCache)')"
        DependsOnTargets="$(UnmanagedUnregistrationDependsOn)">

        <UnregisterAssembly AssemblyListFile="@(_UnmanagedRegistrationCache)"/>

    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                ResolveReferences Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        ResolveReferences
    ============================================================
    -->
    <PropertyGroup>
        <ResolveReferencesDependsOn>
            BeforeResolveReferences;
            SplitProjectReferencesByType;
            ResolveProjectReferences;
            ResolveVCProjectReferences;
            ResolveNativeReferences;
            ResolveAssemblyReferences;
            ResolveComReferences;
            AfterResolveReferences
        </ResolveReferencesDependsOn>
    </PropertyGroup>
    <Target
        Name="ResolveReferences"
        DependsOnTargets="$(ResolveReferencesDependsOn)"/>

    <!--
    ============================================================
                                        BeforeResolveReferences

    Redefine this target in your project in order to run tasks just before ResolveReferences
    ============================================================
    -->
    <Target Name="BeforeResolveReferences"/>

    <!--
    ============================================================
                                        AfterResolveReferences

    Redefine this target in your project in order to run tasks just after ResolveReferences
    ============================================================
    -->
    <Target Name="AfterResolveReferences"/>

    <!--
    ============================================================
                                        SplitProjectReferencesByType

    Split project references into two lists: VC project references and all others (handled by the MSBuild engine)

        [IN]
        @(ProjectReference) - the list of all project references

        [OUT]
        @(VCProjectReference) - the list of VC (managed VC++ to be exact) project references
        @(NonVCProjectReference) - the list of non-VC project references (MSBuild and potentially VSIP projects)
    ============================================================
    -->
    <Target
        Name="SplitProjectReferencesByType"
        Condition="'@(ProjectReference)'!=''">

        <!-- Assign a project configuration to each project reference if we're building a solution file. -->
        <AssignProjectConfiguration
            ProjectReferences="@(ProjectReference)"
            SolutionConfigurationContents="$(CurrentSolutionConfigurationContents)"
            Condition="'$(BuildingSolutionFile)'=='true'">

            <Output TaskParameter="AssignedProjects" ItemName="_ProjectReferenceWithConfiguration"/>

        </AssignProjectConfiguration>

        <ItemGroup>
            <!--
            Otherwise (regular command line build or building inside the IDE) just copy the references
            as we don't need their configurations
            -->
            <_ProjectReferenceWithConfiguration Condition="'$(BuildingSolutionFile)'!='true'" Include="@(ProjectReference)"/>
        </ItemGroup>

        <ItemGroup>
            <!-- Copy all VC project references to the VCProjectReference item list (using the VC project extension) -->
            <VCProjectReference Include="@(_ProjectReferenceWithConfiguration)" Condition="'%(Extension)'=='.vcproj'"/>

            <!-- Copy the rest of the project references to the NonVCProjectReference item list -->
            <NonVCProjectReference Include="@(_ProjectReferenceWithConfiguration)" Condition="'%(Extension)'!='.vcproj'"/>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        _SplitProjectReferencesByFileExistence

    Split referenced projects into two lists: those that exist on
    disk and those that don't.
    ============================================================
    -->
  <Target
    Name="_SplitProjectReferencesByFileExistence">

        <!--
        Use this task for matching projects with pre-resolved project outputs set by the IDE
        if building inside the IDE.  The IDE only includes non-MSBuild projects in the output list.  We'll
        use MSBuild to resolve MSBuild projects.
        This task will resolve VSIP (3rd party) project references and create a new item list with only project references
        to projects in the MSBuild format.
        -->
        <ResolveNonMSBuildProjectOutput
            ProjectReferences="@(NonVCProjectReference)"
            PreresolvedProjectOutputs="$(VSIDEResolvedNonMSBuildProjectOutputs)"
            Condition="'$(BuildingInsideVisualStudio)'=='true' and '@(NonVCProjectReference)'!=''">

            <Output TaskParameter="ResolvedOutputPaths" ItemName="_ResolvedProjectReferencePaths"/>
            <Output TaskParameter="UnresolvedProjectReferences" ItemName="_MSBuildProjectReference"/>

       </ResolveNonMSBuildProjectOutput>

       <!--
       If building from the command line, simply copy the NonVCProjectReference item list to _MSBuildProjectReference,
       since we have to assume all non-VC projects are in the MSBuild format. We have no way of building
       VSIP (3rd party) projects from the command line.
       -->
       <ItemGroup>
         <_MSBuildProjectReference Include="@(NonVCProjectReference)" Condition="'$(BuildingInsideVisualStudio)'!='true' and '@(NonVCProjectReference)'!=''"/>
       </ItemGroup>

       <!-- Break the project list into two lists: those that exist on disk and those that don't. -->
       <ItemGroup>
           <_MSBuildProjectReferenceExistent Include="@(_MSBuildProjectReference)" Condition="Exists('%(Identity)')"/>
           <_MSBuildProjectReferenceNonexistent Include="@(_MSBuildProjectReference)" Condition="!Exists('%(Identity)')"/>
       </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        ResolveProjectReferences

    Build referenced projects:

        [IN]
        @(NonVCProjectReference) - The list of non-VC project references.

        [OUT]
        @(_ResolvedProjectReferencePaths) - Paths to referenced projects.
    ============================================================
    -->
    <Target
        Name="ResolveProjectReferences"
        DependsOnTargets="SplitProjectReferencesByType;_SplitProjectReferencesByFileExistence">

        <!--
        When building this project from the IDE or when building a .SLN from the command-line,
        just gather the referenced build outputs.  The code that builds the .SLN will already have
        built the project, so there's no need to do it again here.

        The ContinueOnError setting is here so that, during project load, as
        much information as possible will be passed to the compilers.
        -->
        <MSBuild
            Projects="@(_MSBuildProjectReferenceExistent)"
            Targets="GetTargetPath"
            BuildInParallel="$(BuildInParallel)"
            UnloadProjectsOnCompletion="$(UnloadProjectsOnCompletion)"
            Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)"
            Condition="'@(NonVCProjectReference)'!='' and ('$(BuildingSolutionFile)' == 'true' or '$(BuildingInsideVisualStudio)' == 'true' or '$(BuildProjectReferences)' != 'true') and '@(_MSBuildProjectReferenceExistent)' != ''"
            ContinueOnError="!$(BuildingProject)">

            <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths"/>

        </MSBuild>

        <!--
        Build referenced projects when building from the command line.

        The $(ProjectReferenceBuildTargets) will normally be blank so that the project's default
        target is used during a P2P reference. However if a custom build process requires that
        the referenced project has a different target to build it can be specified.
        -->
        <MSBuild
            Projects="@(_MSBuildProjectReferenceExistent)"
            Targets="$(ProjectReferenceBuildTargets)"
            BuildInParallel="$(BuildInParallel)"
            UnloadProjectsOnCompletion="$(UnloadProjectsOnCompletion)"
            Condition="'@(NonVCProjectReference)'!='' and '$(BuildingInsideVisualStudio)' != 'true' and '$(BuildingSolutionFile)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''">

            <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths"/>

        </MSBuild>

        <!--
        Get manifest items from the (non-exe) built project references (to feed them into ResolveNativeReference).
        -->
        <MSBuild
            Projects="@(_MSBuildProjectReferenceExistent)"
            Targets="GetNativeManifest"
            BuildInParallel="$(BuildInParallel)"
            UnloadProjectsOnCompletion="$(UnloadProjectsOnCompletion)"
            Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)"
            Condition="'@(NonVCProjectReference)'!='' and '$(BuildingProject)'=='true' and '@(_MSBuildProjectReferenceExistent)'!=''">

            <Output TaskParameter="TargetOutputs" ItemName="NativeReference"/>

        </MSBuild>

        <!-- Issue a warning for each non-existent project. -->
        <Warning
            Text="The referenced project '%(_MSBuildProjectReferenceNonexistent.Identity)' does not exist."
            Condition="'@(NonVCProjectReference)'!='' and '@(_MSBuildProjectReferenceNonexistent)'!=''"/>

    </Target>

    <!--
    ============================================================
                                        GetTargetPath

    This stand-alone target returns the name of the build product (i.e. EXE, DLL)
    that would be produced if we built this project.
    ============================================================
    -->
    <Target
        Name="GetTargetPath"
        Outputs="$(TargetPath)"/>

    <!--
    ============================================================
                                        GetNativeManifest

    Compute the manifest item for this project.

        [IN]
        $(_DeploymentApplicationManifestIdentity) - the manifest identity
        @(ApplicationManifest)         - the original application manifest item

        [OUT]
        @(ComputedApplicationManifest) - application manifest item with full hint path, if generated
    ============================================================
    -->
    <Target
        Name="GetNativeManifest"
        Outputs="@(ComputedApplicationManifest)">

        <ItemGroup>
            <ComputedApplicationManifest Include="$(_DeploymentApplicationManifestIdentity)" Condition="'$(OutputType)'!='winexe' and '$(OutputType)'!='exe' and Exists('%(_ApplicationManifestFinal.FullPath)')">
                <HintPath>%(_ApplicationManifestFinal.FullPath)</HintPath>
            </ComputedApplicationManifest>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        ResolveVCProjectReferences

    Find outputs of referenced VC projects (currently we never build VC projects ourselves)

        [IN]
        @(VCProjectReference) - the list of VC project references

        [OUT]
        @(_ResolvedProjectReferencePaths) - paths to projects' outputs
    ============================================================
    -->

    <Target
        Name="ResolveVCProjectReferences"
        DependsOnTargets="SplitProjectReferencesByType">

        <!--
        Use the task for matching projects with pre-resolved project outputs set by the IDE
        if building inside the IDE
        -->
        <ResolveNonMSBuildProjectOutput
            ProjectReferences="@(VCProjectReference)"
            PreresolvedProjectOutputs="$(VSIDEResolvedNonMSBuildProjectOutputs)"
            Condition="'$(BuildingInsideVisualStudio)'=='true' and '@(VCProjectReference)'!=''">

            <Output TaskParameter="ResolvedOutputPaths" ItemName="_ResolvedVCProjectReferencePaths"/>

        </ResolveNonMSBuildProjectOutput>

        <!--
        Use the task that uses VC project engine if building from the command line.
        Invoking this task only makes sense for building solution files, otherwise
        we won't have the necessary configuration information.
        -->
        <ResolveVCProjectOutput
            ProjectReferences="@(VCProjectReference)"
            Configuration="%(VCProjectReference.FullConfiguration)"
            SolutionFile="$(SolutionPath)"
            Override="$(VCBuildOverride)"
            Condition="'$(BuildingSolutionFile)'=='true' and '@(VCProjectReference)'!=''">

            <Output TaskParameter="ResolvedOutputPaths" ItemName="_ResolvedVCProjectReferencePaths"/>

        </ResolveVCProjectOutput>

        <Error
            Text="MSBuild cannot resolve the reference to the Visual C++ project '%(VCProjectReference.Identity)' when building a stand-alone MSBuild project. To correctly resolve this reference, please build the solution file containing these projects."
            Condition="'$(BuildingSolutionFile)'!='true' and '$(BuildingInsideVisualStudio)'!='true' and '@(VCProjectReference)'!=''"
            />

        <ItemGroup Condition="'@(VCProjectReference)'!=''">
            <NativeReference Include="@(_ResolvedVCProjectReferencePaths->'Native.%(Filename)%(Extension)')" Condition="Exists('%(_ResolvedVCProjectReferencePaths.FullPath).manifest')">
                <HintPath>%(_ResolvedVCProjectReferencePaths.FullPath).manifest</HintPath>
            </NativeReference>
            <_ResolvedProjectReferencePaths Include="@(_ResolvedVCProjectReferencePaths)"/>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        ResolveNativeReferences

    Resolve native references

        [IN]
        @(NativeReference) - The manifest reference (or list of manifest references)

        [OUT]
        @(NativeReferenceFile)  - List of manifest files referenced.
        @(_DeploymentNativePrerequisite)   - List of native assembly prerequisites contained in the manifest.
        @(ComClassReference)    - List of COM components contained in the manifest.
        @(COMReferenceFromNative) List of type libraries contained in the manifest.
        @(COMFileReference)     - List of loose files contained in the manifest.
        @(_DeploymentLooseManifestFile)    - List of extra files that should be published.
    ============================================================
    -->
    <Target
        Name="ResolveNativeReferences"
        Condition="'@(NativeReference)'!=''"
        DependsOnTargets="ResolveProjectReferences;ResolveVCProjectReferences">

        <ResolveNativeReference
            NativeReferences="@(NativeReference)"
            AdditionalSearchPaths="$(ReferencePath);$(OutDir)"
            >
            <Output TaskParameter="ContainingReferenceFiles" ItemName="NativeReferenceFile"/>
            <Output TaskParameter="ContainedPrerequisiteAssemblies" ItemName="_DeploymentNativePrerequisite"/>
            <Output TaskParameter="ContainedComComponents" ItemName="ComClassReference"/>
            <Output TaskParameter="ContainedTypeLibraries" ItemName="COMReferenceFromNative"/>
            <Output TaskParameter="ContainedLooseTlbFiles" ItemName="COMFileReference"/>
            <Output TaskParameter="ContainedLooseEtcFiles" ItemName="_DeploymentLooseManifestFile"/>
        </ResolveNativeReference>

    </Target>
  
    <!--
    ============================================================

                                        ResolveAssemblyReferences

    Given the list of assemblies, find the closure of all assemblies that they depend on. These are
    what we need to copy to the output directory.

        [IN]
        @(Reference) - List of assembly references as fusion names.
        @(_ResolvedProjectReferencePaths) - List of project references produced by projects that this project depends on.

            The 'Private' attribute on the reference corresponds to the Copy Local flag in IDE.
            The 'Private' flag can have three possible values:
                - 'True' means the reference should be Copied Local
                - 'False' means the reference should not be Copied Local
                - [Missing] means this task will decide whether to treat this reference as CopyLocal or not.

        [OUT]
        @(ReferencePath) - Paths to resolved primary files.
        @(ReferenceDependencyPaths) - Paths to resolved dependency files.
        @(_ReferenceRelatedPaths) - Paths to .xmls and .pdbs.
        @(ReferenceSatellitePaths) - Paths to satellites.
        @(_ReferenceSerializationAssemblyPaths) - Paths to XML serialization assemblies created by sgen.
        @(_ReferenceScatterPaths) - Paths to scatter files.
        @(ReferenceCopyLocalPaths) - Paths to files that should be copied to the local directory.
    ============================================================
    -->
    <PropertyGroup>
        <ResolveAssemblyReferencesDependsOn>
            GetFrameworkPaths;
            GetReferenceAssemblyPaths;
            PrepareForBuild
        </ResolveAssemblyReferencesDependsOn>
    </PropertyGroup>
    

    <Target
        Name="ResolveAssemblyReferences"
        Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!=''"
        DependsOnTargets="$(ResolveAssemblyReferencesDependsOn)">
      
        <ItemGroup>
          <_ReferenceInstalledAssemblyDirectory Include="$(TargetFrameworkDirectory)" />
          <_ReferenceInstalledAssemblySubsets Include="$(TargetFrameworkSubset)" />
        </ItemGroup>

      <!--
        Only read and write cache file at build time, skip it for load time because its more
        expensive to write the newly created cache file.
        -->
        <PropertyGroup>
            <ResolveAssemblyReferencesStateFile Condition="'$(BuildingProject)'=='true'">$(IntermediateOutputPath)ResolveAssemblyReference.cache</ResolveAssemblyReferencesStateFile>

        </PropertyGroup>

        <!-- Make an App.Config item that exists when AutoUnify is false. -->
        <ItemGroup>
            <_ResolveAssemblyReferencesApplicationConfigFileForExes Include="@(AppConfigWithTargetPath)" Condition="'$(AutoUnifyAssemblyReferences)'=='false'"/>
        </ItemGroup>

        <PropertyGroup>
            <!-- Default in task is true -->
            <_FindDependencies Condition="'$(BuildingProject)' != 'true' or '$(_ResolveReferenceDependencies)' != 'true'">false</_FindDependencies>
        </PropertyGroup>

        <ResolveAssemblyReference
            Assemblies="@(Reference)"
            AssemblyFiles="@(_ResolvedProjectReferencePaths)"
            TargetFrameworkDirectories="@(_ReferenceInstalledAssemblyDirectory)"
            InstalledAssemblyTables="@(InstalledAssemblyTables);@(RedistList)"
            CandidateAssemblyFiles="@(Content);@(None)"
            SearchPaths="$(AssemblySearchPaths)"
            AllowedAssemblyExtensions="$(AllowedReferenceAssemblyFileExtensions)"
            AllowedRelatedFileExtensions="$(AllowedReferenceRelatedFileExtensions)"
            TargetProcessorArchitecture="$(ProcessorArchitecture)"
            AppConfigFile="@(_ResolveAssemblyReferencesApplicationConfigFileForExes)"
            AutoUnify="$(AutoUnifyAssemblyReferences)"
            FindDependencies="$(_FindDependencies)"
            FindSatellites="$(BuildingProject)"
            FindSerializationAssemblies="$(BuildingProject)"
            FindRelatedFiles="$(BuildingProject)"
            Silent="!$(BuildingProject)"
            IgnoreDefaultInstalledAssemblyTables="$(IgnoreInstalledAssemblyTables)"
            IgnoreDefaultInstalledAssemblySubsetTables="$(IgnoreInstalledAssemblySubsetTables)"
            TargetFrameworkVersion="$(TargetFrameworkVersion)"
            StateFile="$(ResolveAssemblyReferencesStateFile)"
            InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)"
            TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)"
            FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)">

            <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath"/>
            <Output TaskParameter="ResolvedFiles" ItemName="_ResolveAssemblyReferenceResolvedFiles"/>
            <Output TaskParameter="ResolvedDependencyFiles" ItemName="ReferenceDependencyPaths"/>
            <Output TaskParameter="RelatedFiles" ItemName="_ReferenceRelatedPaths"/>
            <Output TaskParameter="SatelliteFiles" ItemName="ReferenceSatellitePaths"/>
            <Output TaskParameter="SerializationAssemblyFiles" ItemName="_ReferenceSerializationAssemblyPaths"/>
            <Output TaskParameter="ScatterFiles" ItemName="_ReferenceScatterPaths"/>
            <Output TaskParameter="CopyLocalFiles" ItemName="ReferenceCopyLocalPaths"/>
            <Output TaskParameter="SuggestedRedirects" ItemName="SuggestedBindingRedirects"/>
            <Output TaskParameter="FilesWritten" ItemName="FileWrites"/>

        </ResolveAssemblyReference>

    </Target>

    <!--
    ============================================================
                                        ResolveComReferences

    Resolve COM references

        [IN]
        @(COMReference) - The list of COM references
        $(BaseIntermediateOutputPath) - The output directory in which to generate wrapper assemblies

        [OUT]
        @(ReferencePath) - Paths to referenced wrappers.

        If ResolveComReferences is invoked from the IDE, PrepareForBuild may need to run to create directories.
    ============================================================
    -->
    <Target
        Name="ResolveComReferences"
        Condition="'@(COMReference)'!='' or '@(COMFileReference)'!=''"
        DependsOnTargets="PrepareForBuild;ResolveKeySource;ResolveAssemblyReferences"
        >

        <!--
        Note: This task should not be batched, since it relies on having all the COM references fed into it at once.
        -->
        <ResolveComReference
              TypeLibNames="@(COMReference)"
              TypeLibFiles="@(COMFileReference)"
              ResolvedAssemblyReferences="@(ReferencePath)"
              WrapperOutputDirectory="$(IntermediateOutputPath)"
              KeyContainer="$(KeyContainerName)"
              KeyFile="$(KeyOriginatorFile)"
              DelaySign="$(DelaySign)"
              StateFile="@(_ResolveComReferenceCache)"
              NoClassMembers="$(ComReferenceNoClassMembers)">

            <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath"/>
            <Output TaskParameter="ResolvedFiles" ItemName="ComReferenceWrappers"/>
            <Output TaskParameter="ResolvedFiles" ItemName="FileWrites"/>
            <!-- This output list only includes items with Isolated attribute set to True.  It's done by the task itself. -->
            <Output TaskParameter="ResolvedModules" ItemName="ResolvedIsolatedComModules"/>

        </ResolveComReference>

        <ItemGroup>
            <FileWrites Include="@(_ResolveComReferenceCache)"/>
            <ReferenceComWrappersToCopyLocal Include="@(ComReferenceWrappers)" Condition="'%(ComReferenceWrappers.CopyLocal)'!='false'"/>
        </ItemGroup>

    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareResources Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        PrepareResources

    Prepare resources for the Compile step.
    ============================================================
    -->
    <PropertyGroup>
        <PrepareResourcesDependsOn>
            PrepareResourceNames;
            ResGen;
            CompileLicxFiles
        </PrepareResourcesDependsOn>
    </PropertyGroup>
    <Target
        Name="PrepareResources"
        DependsOnTargets="$(PrepareResourcesDependsOn)"/>

    <!--
    ============================================================
                                        PrepareResourceNames

    Prepare the names of resource files.
    ============================================================
    -->
    <PropertyGroup>
        <PrepareResourceNamesDependsOn>
            AssignTargetPaths;
            SplitResourcesByCulture;
            CreateManifestResourceNames;
            CreateCustomManifestResourceNames            
        </PrepareResourceNamesDependsOn>
    </PropertyGroup>
    <Target
        Name="PrepareResourceNames"
        DependsOnTargets="$(PrepareResourceNamesDependsOn)"/>

    <!--
    ============================================================
                                        AssignTargetPaths

    This target creates <TargetPath> tags for items. <TargetPath> is a relative folder plus filename
    for the destination of this item.
    ============================================================
    -->
    <PropertyGroup>
        <AssignTargetPathsDependsOn></AssignTargetPathsDependsOn>
    </PropertyGroup>
    <Target
        Name="AssignTargetPaths"
        DependsOnTargets="$(AssignTargetPathsDependsOn)">

        <ItemGroup>
            <_Temporary Remove="@(_Temporary)" />
        </ItemGroup>
        
        <!-- AssignTargetPath generates TargetPath metadata that is consumed by CreateManifestResourceNames target for manifest name generation -->        
        <AssignTargetPath Files="@(EmbeddedResource)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="_Temporary" />
        </AssignTargetPath>

                            
        <ItemGroup>
            <!-- Replace items in EmbeddedResource with the items emitted by the AssignTargetPath task that have the TargetPath metadata -->
            <EmbeddedResource Remove="@(_Temporary)" />            
            <EmbeddedResource Include="@(_Temporary)" />            
            <_Temporary Remove="@(_Temporary)" />
        </ItemGroup>
      
        <AssignTargetPath Files="@(Content)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="ContentWithTargetPath" />
        </AssignTargetPath>

        <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="_NoneWithTargetPath" />
        </AssignTargetPath>

        <AssignTargetPath Files="@(BaseApplicationManifest)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="_DeploymentBaseManifestWithTargetPath"/>
        </AssignTargetPath>
        
        <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)" Condition="'@(_DeploymentBaseManifestWithTargetPath)'=='' and '%(None.Extension)'=='.manifest'">
            <Output TaskParameter="AssignedFiles" ItemName="_DeploymentBaseManifestWithTargetPath" />
        </AssignTargetPath>
        
    </Target>

    <!--
    ============================================================
                                        SplitResourcesByCulture

    Split EmbeddedResource items into five lists based on whether
    they are resx files, licx files or other resources and whether they should be localized. Also adds Type and Culture
    metadata. Type indicates whether the resource is "Resx" or "Non-Resx".

        [IN]/[OUT]
        @(EmbeddedResource) - The raw list of resources.

        [OUT]
        @(_LicxFile) - The EmbeddedResource items with extension equal to '.licx'.
    ============================================================
    -->
    <Target
        Name="SplitResourcesByCulture"
        DependsOnTargets="AssignTargetPaths">

        <Warning Condition="'@(ResxWithNoCulture)'!=''" Code="MSB9000" Text="ResxWithNoCulture item type is deprecated. Use EmbeddedResource items instead."/>
        <Warning Condition="'@(ResxWithCulture)'!=''" Code="MSB9001" Text="ResxWithCulture item type is deprecated. Use EmbeddedResource items instead."/>
        <Warning Condition="'@(NonResxWithCulture)'!=''" Code="MSB9002" Text="NonResxWithCulture item type is deprecated. Use EmbeddedResource items instead."/>
        <Warning Condition="'@(NonResxWithNoCulture)'!=''" Code="MSB9003" Text="NonResxWithNoCulture item type is deprecated. Use EmbeddedResource items instead."/>
           
        <ItemGroup>
            <_LicxFile Include="@(EmbeddedResource)" Condition="'%(Extension)'=='.licx'"/>

            <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
            <EmbeddedResource Include="@(ResxWithNoCulture);@(ResxWithCulture)">
                <Type>Resx</Type>
            </EmbeddedResource>
            <EmbeddedResource Include="@(NonResxWithCulture);@(NonResxWithNoCulture)">
                <Type>Non-Resx</Type>
            </EmbeddedResource>
        </ItemGroup>

        <AssignCulture Files="@(EmbeddedResource)" Condition="'%(Extension)'!='.licx'">
            <!-- Create the list of culture resx and embedded resource files -->
            <Output TaskParameter="AssignedFilesWithCulture" ItemName="_MixedResourceWithCulture"/>
            <!-- Create the list of non-culture resx and embedded resource files -->
            <Output TaskParameter="AssignedFilesWithNoCulture" ItemName="_MixedResourceWithNoCulture"/>
        </AssignCulture>

        <ItemGroup>
          
            <!-- Remove EmbeddedResource items that we have processed already
                 i.e. either Licx, or resources that don't have culture info -->
            <EmbeddedResource Remove="@(_MixedResourceWithCulture)" />
            <EmbeddedResource Remove="@(_MixedResourceWithNoCulture)" />
            <EmbeddedResource Remove="@(_LicxFile)" />
          
            <!-- Add back everything except Licx, so that we have culture info -->
            <EmbeddedResource Include="@(_MixedResourceWithNoCulture);@(_MixedResourceWithCulture)" Condition="'%(Extension)'=='.resx' or '%(Extension)'=='.restext'">
                <Type Condition="'%(_MixedResourceWithNoCulture.Type)'=='' and '%(_MixedResourceWithCulture.Type)'==''">Resx</Type>
            </EmbeddedResource>
            <EmbeddedResource Include="@(_MixedResourceWithNoCulture);@(_MixedResourceWithCulture)" Condition="'%(Extension)'!='.resx' and '%(Extension)'!='.restext'">
                <Type Condition="'%(_MixedResourceWithNoCulture.Type)'=='' and '%(_MixedResourceWithCulture.Type)'==''">Non-Resx</Type>
            </EmbeddedResource>

            <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
            <ResxWithNoCulture Remove="@(ResxWithNoCulture)"/>
            <NonResxWithNoCulture Remove="@(NonResxWithNoCulture)"/>
            <ResxWithCulture Remove="@(ResxWithCulture)"/>
            <NonResxWithCulture Remove="@(NonResxWithCulture)"/>
            <ResxWithNoCulture Include="@(_MixedResourceWithNoCulture)" Condition="'%(WithCulture)'=='false' and ('%(Extension)'=='.resx' or '%(Extension)'=='.restext')"/>
            <NonResxWithNoCulture Include="@(_MixedResourceWithNoCulture)" Condition="'%(WithCulture)'=='false' and ('%(Extension)'!='.resx' and '%(Extension)'!='.restext')"/>
            <ResxWithCulture Include="@(_MixedResourceWithCulture)" Condition="'%(WithCulture)'=='true' and ('%(Extension)'=='.resx' or '%(Extension)'=='.restext')"/>
            <NonResxWithCulture Include="@(_MixedResourceWithCulture)" Condition="'%(WithCulture)'=='true' and ('%(Extension)'!='.resx' and '%(Extension)'!='.restext')"/>

            <!-- Clean up temporary lists -->
            <_MixedResourceWithNoCulture Remove="@(_MixedResourceWithNoCulture)" />            
            <_MixedResourceWithCulture Remove="@(_MixedResourceWithCulture)" />
            
        </ItemGroup>        
                
    </Target>        

    <!--
    =======================================================================
                                        CreateCustomManifestResourceNames

    Allows custom manifest resource name generation tasks to plug
    into the build process
    =======================================================================
    -->
    <PropertyGroup>
      <CreateCustomManifestResourceNamesDependsOn></CreateCustomManifestResourceNamesDependsOn>
    </PropertyGroup>
    <Target
        Name="CreateCustomManifestResourceNames"
        DependsOnTargets="$(CreateCustomManifestResourceNamesDependsOn)"/>
    
    <!--
    ============================================================
                                        ResGen

    Run GenerateResource on the given resx files.

    ============================================================
    -->
    <PropertyGroup>
        <ResGenDependsOn>ResolveAssemblyReferences;SplitResourcesByCulture;BeforeResGen;CoreResGen;AfterResGen</ResGenDependsOn>
        <CoreResGenDependsOn></CoreResGenDependsOn>
        <UseSourcePath Condition="'$(UseSourcePath)'==''">true</UseSourcePath>
    </PropertyGroup>
    <Target
        Name="ResGen"
        DependsOnTargets="$(ResGenDependsOn)"/>

    <!--
    ============================================================
                                        BeforeResGen

    Redefine this target in your project in order to run tasks just before Resgen.
    ============================================================
    -->
    <Target Name="BeforeResGen"/>

    <!--
    ============================================================
                                        AfterResGen

    Redefine this target in your project in order to run tasks just after Resgen.
    ============================================================
    -->
    <Target Name="AfterResGen"/>

    <!--
    ============================================================
                                        CoreResGen
    ============================================================
    -->
    <Target
        Name="CoreResGen"
        DependsOnTargets="$(CoreResGenDependsOn)">

        <ItemGroup>          
            <_Temporary Remove="@(_Temporary)" />
        </ItemGroup>
        
        <GenerateResource
            Sources="@(EmbeddedResource)"
            UseSourcePath="$(UseSourcePath)"
            References="@(ReferencePath)"
            AdditionalInputs="$(MSBuildAllProjects)"
            NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)"
            StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.Cache"            
            StronglyTypedClassName="%(EmbeddedResource.StronglyTypedClassName)"
            StronglyTypedFileName="%(EmbeddedResource.StronglyTypedFileName)"
            StronglyTypedLanguage="%(EmbeddedResource.StronglyTypedLanguage)"
            StronglyTypedNamespace="%(EmbeddedResource.StronglyTypedNamespace)"
            StronglyTypedManifestPrefix="%(EmbeddedResource.StronglyTypedManifestPrefix)" 
            PublicClass="%(EmbeddedResource.PublicClass)"
            OutputResources="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources')"
            Condition=" '%(EmbeddedResource.Type)' == 'Resx' and '%(EmbeddedResource.GenerateResource)' != 'false'">
                                 
            <Output TaskParameter="FilesWritten" ItemName="FileWrites"/>
            <Output TaskParameter="StronglyTypedFileName" ItemName="Compile"/>
            
            <!-- Gather Sources as an output since it will contain OutputResource metadata indicating the final output resource that it was compiled into -->
            <Output TaskParameter="Sources" ItemName="_Temporary" />
          
        </GenerateResource>

        <ItemGroup>                  
            <EmbeddedResource Remove="@(_Temporary)" />

            <!-- Add back the Sources list (with OutputResource metadata) that we output from GenerateResource into EmbeddedResource -->
            <EmbeddedResource Include="@(_Temporary)" />            
            <_Temporary Remove="@(_Temporary)" />
          
            <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
            <ManifestResourceWithNoCulture Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)'=='false' and '%(EmbeddedResource.Type)' == 'Resx'">
                <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
            </ManifestResourceWithNoCulture>
            <ManifestNonResxWithNoCultureOnDisk Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)'=='false' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
                <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
            </ManifestNonResxWithNoCultureOnDisk>            
            
            <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->        
            <ManifestResourceWithCulture Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)'=='true' and '%(EmbeddedResource.Type)' == 'Resx'">
                <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
            </ManifestResourceWithCulture>            
            <ManifestNonResxWithCultureOnDisk Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)'=='true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
                <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
            </ManifestNonResxWithCultureOnDisk>            
            
        </ItemGroup>      
      
    </Target>

    <!--
    ============================================================
                                        CompileLicxFiles

    Compile .licx files (containing information about licensed controls used by the application) into .licenses files.

        [IN]
        @(_LicxFile) - The list of .licx files in the project (usually there will be just one)

        [OUT]
        @(CompiledLicenseFile) - The list of compiled .licenses files (there will be just one)
    ============================================================
    -->
    <PropertyGroup>
        <CompileLicxFilesDependsOn></CompileLicxFilesDependsOn>
    </PropertyGroup>
    <Target
        Name="CompileLicxFiles"
        Condition="'@(_LicxFile)'!=''"
        DependsOnTargets="$(CompileLicxFilesDependsOn)"
        Inputs="$(MSBuildAllProjects);@(_LicxFile);@(ReferencePath);@(ReferenceDependencyPaths)"
        Outputs="$(IntermediateOutputPath)$(TargetFileName).licenses">

        <LC
            Sources="@(_LicxFile)"
            LicenseTarget="$(TargetFileName)"
            OutputDirectory="$(IntermediateOutputPath)"
            OutputLicense="$(IntermediateOutputPath)$(TargetFileName).licenses"
            ReferencedAssemblies="@(ReferencePath);@(ReferenceDependencyPaths)"
            ToolPath="$(LCToolPath)">

            <Output TaskParameter="OutputLicense" ItemName="CompiledLicenseFile"/>
            <Output TaskParameter="OutputLicense" ItemName="FileWrites"/>

        </LC>

    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                ResolveKeySource Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        ResolveKeySource

    Resolve the strong name key used to sign the assembly as well as the certificate used to
    sign the ClickOnce manifests.

        [IN]
        $(AssemblyOriginatorKeyFile)     - The file used to sign the assembly (.snk or .pfx)
        $(ManifestCertificateThumbprint) - The thumbprint used to locate the certificate in the
                                           user's certificate store.
        $(ManifestKeyFile)               - The key file that contains the certificate in case the
                                           certificate is not in the user's store.

        [OUT]
        $(ResolvedAssemblyKeyFile)        - Key used to sign the assembly
        $(_DeploymentResolvedManifestCertificateThumbprint) - Certificate used to sign the manifests
    ============================================================
    -->
    <Target
        Name="ResolveKeySource"
        Condition="$(SignManifests) == 'true' or $(SignAssembly) == 'true'">

      <ResolveKeySource
          KeyFile="$(AssemblyOriginatorKeyFile)"
          CertificateThumbprint="$(ManifestCertificateThumbprint)"
          CertificateFile="$(ManifestKeyFile)"
          SuppressAutoClosePasswordPrompt="$(BuildingInsideVisualStudio)"
          ShowImportDialogDespitePreviousFailures="$(BuildingProject)"
          ContinueOnError="!$(BuildingProject)"
          >

        <Output TaskParameter="ResolvedKeyFile" PropertyName="KeyOriginatorFile" Condition=" '$(SignAssembly)' == 'true' "/>
        <Output TaskParameter="ResolvedKeyContainer" PropertyName="KeyContainerName" Condition=" '$(SignAssembly)' == 'true' "/>
        <Output TaskParameter="ResolvedThumbprint" PropertyName="_DeploymentResolvedManifestCertificateThumbprint" Condition=" '$(SignManifests)' == 'true' "/>

      </ResolveKeySource>

    </Target>

    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Compile Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        Compile
    ============================================================
    -->
    <PropertyGroup>
        <CompileDependsOn>
          ResolveReferences;
          ResolveKeySource;
          SetWin32ManifestProperties;
          _GenerateCompileInputs;
          BeforeCompile;
          _TimeStampBeforeCompile;
          CoreCompile;
          _TimeStampAfterCompile;
          AfterCompile
        </CompileDependsOn>
    </PropertyGroup>
    <Target
        Name="Compile"
        DependsOnTargets="$(CompileDependsOn)"/>
        
    <!--
    ============================================================
                                        _GenerateCompileInputs

    Create the _CoreCompileResourceInputs list of inputs to the CoreCompile target.
    ============================================================
    -->    
    <Target Name="_GenerateCompileInputs">        

        <Warning Condition="'@(ManifestResourceWithNoCulture)'!='' and '%(ManifestResourceWithNoCulture.EmittedForCompatibilityOnly)'==''" Code="MSB9004" Text="ManifestResourceWithNoCulture item type is deprecated. Emit EmbeddedResource items instead, with metadata WithCulture='false', Type='Resx', and optional LogicalName."/>
        <Warning Condition="'@(ManifestNonResxWithNoCultureOnDisk)'!='' and '%(ManifestNonResxWithNoCultureOnDisk.EmittedForCompatibilityOnly)'==''" Code="MSB9005" Text="ManifestNonResxWithNoCultureOnDisk item type is deprecated. Emit EmbeddedResource items instead, with metadata WithCulture='false', Type='Non-Resx', and optional LogicalName."/>            

        <ItemGroup>
        
            <!-- _CoreCompileResourceInputs is the list of TLDA inputs that should trigger CoreCompile, and are listed as inputs to that target -->
            <_CoreCompileResourceInputs Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)' == 'false' and '%(EmbeddedResource.Type)' == 'Resx'" />
            <_CoreCompileResourceInputs Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)' == 'false' and '%(EmbeddedResource.Type)' == 'Non-Resx' " />
            
            <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
            <_CoreCompileResourceInputs Include="@(ManifestResourceWithNoCulture)" Condition="'%(ManifestResourceWithNoCulture.EmittedForCompatibilityOnly)'==''">
                <Type>Resx</Type>
                <WithCulture>false</WithCulture>
            </_CoreCompileResourceInputs>
            <_CoreCompileResourceInputs Include="@(ManifestNonResxWithNoCultureOnDisk)" Condition="'%(ManifestNonResxWithNoCultureOnDisk.EmittedForCompatibilityOnly)'==''">
                <Type>Non-Resx</Type>
                <WithCulture>false</WithCulture>
            </_CoreCompileResourceInputs>   
            
        </ItemGroup>
        
    </Target>

    <!--
    ============================================================
                                        BeforeCompile

    Redefine this target in your project in order to run tasks just before Compile.
    ============================================================
    -->
    <Target Name="BeforeCompile"/>

    <!--
    ============================================================
                                        AfterCompile

    Redefine this target in your project in order to run tasks just after Compile.
    ============================================================
    -->
    <Target Name="AfterCompile"/>

    <!--
    ============================================================
                                        _TimeStampBeforeCompile

    If post-build events are set to fire "OnOutputUpdated", then take before
    and after timestamps so that we can compare them.
    ============================================================
    -->
    <Target
        Name="_TimeStampBeforeCompile"
        Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated' or ('$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library')">

        <PropertyGroup>
            <_AssemblyTimestampBeforeCompile>%(IntermediateAssembly.ModifiedTime)</_AssemblyTimestampBeforeCompile>
        </PropertyGroup>

    </Target>

    <!--
    ============================================================
                                        _TimeStampAfterCompile

    If post-build events are set to fire "OnOutputUpdated", then take before
    and after timestamps so that we can compare them.
    ============================================================
    -->
    <Target
        Name="_TimeStampAfterCompile"
        Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated' or ('$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library')">

        <PropertyGroup>
            <_AssemblyTimestampAfterCompile>%(IntermediateAssembly.ModifiedTime)</_AssemblyTimestampAfterCompile>
        </PropertyGroup>

    </Target>

    <!--
    ================================================================
                                        _ComputeNonExistentFileProperty

    There are certain situations in which we want to always run the CoreCompile target (and
    thus the Csc task), even if the timestamps of the outputs appear to be up-to-date on disk.
    If we're inside the IDE during design-time, then the Csc/Vbc/Vjc task is simply being used to
    initialize the host compiler, so we always want to run it.  Also, if we're inside the IDE, and
    the host compiler is responsible for doing the compilation during an actual build, we want to let
    the host compiler determine whether the output is up-to-date, because there may be source files
    in the IDE's in-memory buffers that we don't know about.

    So, we always run the CoreCompile target if we're in the IDE, and either we're in design-time or
    we're delegating to the host compiler for the actual build.
    ================================================================
    -->
    <Target
        Name="_ComputeNonExistentFileProperty"
        Condition="
            ('$(BuildingInsideVisualStudio)' == 'true')
            and
            (
                ('$(BuildingProject)' == 'false')
                or
                ('$(UseHostCompilerIfAvailable)' == 'true')
            )
            ">

        <PropertyGroup>
            <NonExistentFile>__NonExistentSubDir__\__NonExistentFile__</NonExistentFile>
        </PropertyGroup>

    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                GenerateSerializationAssemblies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <PropertyGroup>
        <_SGenDllName>$(TargetName).XmlSerializers.dll</_SGenDllName>
        <_SGenDllCreated>false</_SGenDllCreated>
        <_SGenGenerateSerializationAssembliesConfig>$(GenerateSerializationAssemblies)</_SGenGenerateSerializationAssembliesConfig>
        <_SGenGenerateSerializationAssembliesConfig Condition="'$(GenerateSerializationAssemblies)' == ''">Auto</_SGenGenerateSerializationAssembliesConfig>
        <_SGenGenerateSerializationAssembliesConfig Condition="'$(ConfigurationName)'=='Debug' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto'">Off</_SGenGenerateSerializationAssembliesConfig>
        <SGenUseProxyTypes Condition="'$(SGenUseProxyTypes)' == ''">true</SGenUseProxyTypes>
        <SGenShouldGenerateSerializer Condition="'$(SGenShouldGenerateSerializer)' == ''">true</SGenShouldGenerateSerializer>
    </PropertyGroup>

    <!--
    ============================================================
                                        GenerateSerializationAssemblies

    Run GenerateSerializationAssemblies on the assembly produced by this build.

        [IN]
        @(BuildAssemblyName) - The assembly generated by this build.
        @(BuildAssemblyPath) - The path where the assembly resides.
        @(ReferencePath) - The list of references used by this assembly.

        [OUT]
        @(SerializationAssembly) - The path to the serialization assembly.  Maybe we'll just append to an existing list.
    ============================================================
    -->
    <Target
        Name="GenerateSerializationAssemblies"
        Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')"
        DependsOnTargets="AssignTargetPaths;Compile;ResolveKeySource"
        Inputs="$(MSBuildAllProjects);@(IntermediateAssembly)"
        Outputs="$(IntermediateOutputPath)$(_SGenDllName)">

        <SGen
            BuildAssemblyName="$(TargetFileName)"
            BuildAssemblyPath="$(IntermediateOutputPath)"
            References="@(ReferencePath)"
            ShouldGenerateSerializer="$(SGenShouldGenerateSerializer)"
            UseProxyTypes="$(SGenUseProxyTypes)"
            KeyContainer="$(KeyContainerName)"
            KeyFile="$(KeyOriginatorFile)"
            DelaySign="$(DelaySign)"
            ToolPath="$(SGenToolPath)">

            <Output TaskParameter="SerializationAssembly" ItemName="SerializationAssembly"/>

        </SGen>

    </Target>



    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                CreateSatelliteAssemblies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->  

    <!--
    ============================================================
                                        CreateSatelliteAssemblies

    Create one satellite assembly for every unique culture in the resources.       
    ============================================================
    -->  
    <PropertyGroup>
        <CreateSatelliteAssembliesDependsOn>
            _GenerateSatelliteAssemblyInputs;
            ComputeIntermediateSatelliteAssemblies;
            GenerateSatelliteAssemblies
        </CreateSatelliteAssembliesDependsOn>
    </PropertyGroup>
    <Target
        Name="CreateSatelliteAssemblies"        
        DependsOnTargets="$(CreateSatelliteAssembliesDependsOn)" />    
    
    <!--
    ============================================================
                                        _GenerateSatelliteAssemblyInputs

    Create the _SatelliteAssemblyResourceInputs list of inputs to the CreateSatelliteAssemblies target.
    ============================================================
    -->    
    <Target Name="_GenerateSatelliteAssemblyInputs">

        <Warning Condition="'@(ManifestResourceWithCulture)'!='' and '%(ManifestResourceWithCulture.EmittedForCompatibilityOnly)'==''" Code="MSB9006" Text="ManifestResourceWithCulture item type is deprecated. Emit EmbeddedResource items instead, with metadata WithCulture='true', Type='Resx', and optional LogicalName."/>
        <Warning Condition="'@(ManifestNonResxWithCultureOnDisk)'!='' and '%(ManifestNonResxWithCultureOnDisk.EmittedForCompatibilityOnly)'==''" Code="MSB9007" Text="ManifestNonResxWithCultureOnDisk item type is deprecated. Emit EmbeddedResource items instead, with metadata WithCulture='true', Type='Non-Resx', and optional LogicalName."/>

        <ItemGroup>                  
            <!-- _SatelliteAssemblyResourceInputs is the list of TLDA inputs that should trigger CreateSatelliteAssemblies, so listed as inputs to that target -->
            <_SatelliteAssemblyResourceInputs Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Resx'" />
            <_SatelliteAssemblyResourceInputs Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'" />

            <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
            <_SatelliteAssemblyResourceInputs Include="@(ManifestResourceWithCulture)" Condition="'%(ManifestResourceWithCulture.EmittedForCompatibilityOnly)'==''">
                <Type>Resx</Type>
                <WithCulture>true</WithCulture>
            </_SatelliteAssemblyResourceInputs>
            <_SatelliteAssemblyResourceInputs Include="@(ManifestNonResxWithCultureOnDisk)" Condition="'%(ManifestNonResxWithCultureOnDisk.EmittedForCompatibilityOnly)'==''">
                <Type>Non-Resx</Type>
                <WithCulture>true</WithCulture>
            </_SatelliteAssemblyResourceInputs> 
         
        </ItemGroup>         
    </Target>    
      
    <!--
    ============================================================
                                        GenerateSatelliteAssemblies

    Actually run al.exe to create the satellite assemblies.       
    ============================================================
    -->       
    <Target Name="GenerateSatelliteAssemblies"
            Inputs="$(MSBuildAllProjects);@(_SatelliteAssemblyResourceInputs);$(IntermediateOutputPath)$(TargetName)$(TargetExt)"
            Outputs="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll"
            Condition="'@(_SatelliteAssemblyResourceInputs)' != ''">
        
        <MakeDir
            Directories="@(EmbeddedResource->'$(IntermediateOutputPath)%(Culture)')" />                          
                
        <AL AlgorithmId="$(Satellite_AlgorithmId)"
            BaseAddress="$(Satellite_BaseAddress)"
            CompanyName="$(Satellite_CompanyName)"
            Configuration="$(Satellite_Configuration)"
            Copyright="$(Satellite_Copyright)"
            Culture="%(Culture)"
            DelaySign="$(DelaySign)"
            Description="$(Satellite_Description)"
            EmbedResources="@(_SatelliteAssemblyResourceInputs)"
            EvidenceFile="$(Satellite_EvidenceFile)"
            FileVersion="$(Satellite_FileVersion)"
            Flags="$(Satellite_Flags)"
            GenerateFullPaths="$(Satellite_GenerateFullPaths)"
            KeyContainer="$(KeyContainerName)"
            KeyFile="$(KeyOriginatorFile)"
            LinkResources="@(Satellite_LinkResource)"
            MainEntryPoint="$(Satellite_MainEntryPoint)"
            OutputAssembly="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll"
            Platform="$(PlatformTarget)"
            ProductName="$(Satellite_ProductName)"
            ProductVersion="$(Satellite_ProductVersion)"
            ResponseFiles="@(AlResponseFile)"
            SourceModules="@(Satellite_SourceModule)"
            TargetType="$(Satellite_TargetType)"
            TemplateFile="$(IntermediateOutputPath)$(TargetName)$(TargetExt)"
            Title="$(Satellite_Title)"
            ToolPath="$(AlToolPath)"
            Trademark="$(Satellite_Trademark)"
            Version="$(Satellite_Version)"
            Win32Icon="$(Satellite_Win32Icon)"
            Win32Resource="$(Satellite_Win32Resource)">

            <Output TaskParameter="OutputAssembly" ItemName="FileWrites"/>

        </AL>

    </Target>
    <!--
    ============================================================
                                        ComputeIntermediateSatelliteAssemblies

    Compute the paths to the intermediate satellite assemblies,
    with culture attributes so we can copy them to the right place.
    ============================================================
    -->
    <PropertyGroup>
        <ComputeIntermediateSatelliteAssembliesDependsOn>
            CreateManifestResourceNames
        </ComputeIntermediateSatelliteAssembliesDependsOn>
    </PropertyGroup>
    <Target
        Name="ComputeIntermediateSatelliteAssemblies"
        Condition="@(EmbeddedResource->'%(WithCulture)') != ''"
        DependsOnTargets="$(ComputeIntermediateSatelliteAssembliesDependsOn)">

        <ItemGroup>
            <IntermediateSatelliteAssembliesWithTargetPath Include="$(IntermediateOutputPath)%(EmbeddedResource.Culture)\$(TargetName).resources.dll"
                                                           Condition="'%(EmbeddedResource.Culture)' != ''">
                <Culture>%(EmbeddedResource.Culture)</Culture>
                <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
            </IntermediateSatelliteAssembliesWithTargetPath>
        </ItemGroup>
    </Target>

    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                SetWin32ManifestProperties Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <PropertyGroup>
        <EmbeddedWin32Manifest>$(Win32Manifest)</EmbeddedWin32Manifest>
    </PropertyGroup>

    <!--
    ============================================================
                                        SetWin32ManifestProperties

    Set Win32Manifest and EmbeddedManifest properties to be used later in the build.
    ============================================================
    -->
    <Target
        Name="SetWin32ManifestProperties"
        Condition="'$(Win32Manifest)'==''"
        DependsOnTargets="ResolveComReferences;ResolveNativeReferences;_SetExternalWin32ManifestProperties;_SetEmbeddedWin32ManifestProperties" />

    <Target
        Name="_SetExternalWin32ManifestProperties"
        Condition="'$(GenerateClickOnceManifests)'=='true' or '@(NativeReference)'!='' or '@(ResolvedIsolatedComModules)'!=''" >

        <PropertyGroup>
            <!-- set _DeploymentBaseManifest property to the value of $(ApplicationManifest) if the property is set,
                 but use _DeploymentBaseManifestWithTargetPath item-group if the property is not set to support backwards 
                 compat with earlier MSBuild versions when manifest files were determined by the item-group. If the newer 
                 property is set though, prefer that one be used to specify the manifest. -->
            <_DeploymentBaseManifest>$(ApplicationManifest)</_DeploymentBaseManifest>
            <_DeploymentBaseManifest Condition="'$(_DeploymentBaseManifest)'==''">@(_DeploymentBaseManifestWithTargetPath)</_DeploymentBaseManifest>
            
            <!-- when using external manifests, always set the NoWin32Manifest property to
                 true if there is no value set in the incoming project file so the 
                 compilers that support manifest embedding know not to add
                 a manifest to their built assemblies -->
            <NoWin32Manifest Condition="'$(NoWin32Manifest)'==''">true</NoWin32Manifest>
        </PropertyGroup>

    </Target>

    <Target
        Name="_SetEmbeddedWin32ManifestProperties"
        Condition="'$(GenerateClickOnceManifests)'!='true' and '@(NativeReference)'=='' and '@(ResolvedIsolatedComModules)'==''" >

        <PropertyGroup>
            <EmbeddedWin32Manifest>$(ApplicationManifest)</EmbeddedWin32Manifest>
            <Win32Manifest>$(ApplicationManifest)</Win32Manifest>
        </PropertyGroup>

        <GetFrameworkPath Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true'">
            <Output TaskParameter="FrameworkVersion35Path"  PropertyName="_FrameworkVersion35Path" />
        </GetFrameworkPath>

        <PropertyGroup>
            <EmbeddedWin32Manifest  Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and Exists('$(_FrameworkVersion35Path)\default.win32manifest')">$(_FrameworkVersion35Path)\default.win32manifest</EmbeddedWin32Manifest>
        </PropertyGroup>

     </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                GenerateManifests Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        GenerateManifests

    Generates ClickOnce application and deployment manifests or a native manifest.
    ============================================================
    -->
    <PropertyGroup>
        <GenerateManifestsDependsOn>
            SetWin32ManifestProperties;
            GenerateApplicationManifest;
            GenerateDeploymentManifest
        </GenerateManifestsDependsOn>
    </PropertyGroup>

    <!--
    ============================================================
                  _GenerateResolvedDeploymentManifestEntryPoint

    Use the ResolveManifestFiles to generate the GenerateResolvedDeploymentManifestEntryPoint

    ============================================================
    -->
    <Target
        Name="_GenerateResolvedDeploymentManifestEntryPoint">
        <ItemGroup>
          <_DeploymentPublishFileOfTypeManifestEntryPoint Include="@(PublishFile)" Condition="'%(FileType)'=='ManifestEntryPoint'"/>
        </ItemGroup>

        <ResolveManifestFiles
            TargetFrameworkVersion="$(TargetFrameworkVersion)"
            SigningManifests="$(SignManifests)"
            DeploymentManifestEntryPoint="@(ApplicationManifest)"
            PublishFiles="@(_DeploymentPublishFileOfTypeManifestEntryPoint)">

        <Output TaskParameter="OutputDeploymentManifestEntryPoint" ItemName="_DeploymentResolvedDeploymentManifestEntryPoint"/>

        </ResolveManifestFiles>
    </Target>
  
    <Target
        Name="GenerateManifests"
        Condition="'$(GenerateClickOnceManifests)'=='true' or '@(NativeReference)'!='' or '@(ResolvedIsolatedComModules)'!=''"
        DependsOnTargets="$(GenerateManifestsDependsOn)"/>

    <!--
    ============================================================
                                        GenerateApplicationManifest

    Generates a ClickOnce or native application manifest.
    An application manifest specifies declarative application identity, dependency and security information.

        [IN]
        $(_DeploymentBaseManifest) - The base app.manifest from project.
        @(ResolvedIsolatedComModules) - The list of COM references to be isolated as reg-free COM dependencies for native assembly loader.
        @(_DeploymentManifestFiles) - The list of loose files (content, pdb, xml, etc.) for ClickOnce.
        @(_DeploymentManifestDependencies) - The list of application dependencies (typically this is the set of assembly dependencies in bin\) for ClickOnce.
        @(AppConfigWithTargetPath) - App config file, if present.
        $(_DeploymentManifestType) - Type of manifest to be generated, either "Native" or "ClickOnce".

        [OUT]
        @(ApplicationManifest) - Generated native or ClickOnce application manifest, i.e. WindowsApplication1.exe.manifest
    ============================================================
    -->
    <Target
        Name="GenerateApplicationManifest"
        DependsOnTargets="
            _DeploymentComputeNativeManifestInfo;
            _DeploymentComputeClickOnceManifestInfo;
            ResolveComReferences;
            ResolveNativeReferences;
            _GenerateResolvedDeploymentManifestEntryPoint"
        Inputs="
            $(MSBuildAllProjects);
            @(AppConfigWithTargetPath);
            $(_DeploymentBaseManifest);
            @(ResolvedIsolatedComModules);
            @(_DeploymentManifestDependencies);
            @(_DeploymentResolvedManifestEntryPoint);
            @(_DeploymentManifestFiles)"
        Outputs="@(ApplicationManifest)">

      <RequiresFramework35SP1Assembly
          ReferencedAssemblies="@(Reference)"
            ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)"
            TargetFrameworkVersion="$(TargetFrameworkVersion)"
            CreateDesktopShortcut="$(CreateDesktopShortcut)"
            SigningManifests="$(SignManifests)"
            Assemblies="@(_DeploymentManifestDependencies)"
            DeploymentManifestEntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)"
            EntryPoint="@(_DeploymentResolvedManifestEntryPoint)"
            Files="@(_DeploymentManifestFiles)"
            SuiteName="$(SuiteName)" >

            <Output TaskParameter="RequiresMinimumFramework35SP1" PropertyName="_DeploymentRequiresMinimumFramework35SP1" />
        </RequiresFramework35SP1Assembly>

        <GenerateApplicationManifest
            AssemblyName="$(_DeploymentApplicationManifestIdentity)"
            AssemblyVersion="$(_DeploymentManifestVersion)"
            ConfigFile="@(AppConfigWithTargetPath)"
            ClrVersion="$(ClrVersion)"
            Dependencies="@(_DeploymentManifestDependencies)"
            Description="$(Description)"
            EntryPoint="@(_DeploymentResolvedManifestEntryPoint)"
            ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)"
            FileAssociations="@(FileAssociation)"
            Files="@(_DeploymentManifestFiles)"
            HostInBrowser="$(HostInBrowser)"
            IconFile="@(_DeploymentManifestIconFile)"
            InputManifest="$(_DeploymentBaseManifest)"
            IsolatedComReferences="@(ResolvedIsolatedComModules)"
            ManifestType="$(_DeploymentManifestType)"
            MaxTargetPath="$(MaxTargetPath)"
            OutputManifest="@(ApplicationManifest)"
            OSVersion="$(OSVersion)"
            Platform="$(PlatformTarget)"
            Product="$(ProductName)"
            Publisher="$(PublisherName)"
            RequiresMinimumFramework35SP1="$(_DeploymentRequiresMinimumFramework35SP1)"
            SuiteName="$(SuiteName)"
            SupportUrl="$(_DeploymentFormattedSupportUrl)"
            TargetCulture="$(TargetCulture)"
            TargetFrameworkSubset="$(TargetFrameworkSubset)"
            TargetFrameworkVersion="$(TargetFrameworkVersion)"
            TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)"
            UseApplicationTrust="$(UseApplicationTrust)">

            <Output TaskParameter="OutputManifest" ItemName="FileWrites"/>

        </GenerateApplicationManifest>

        <PropertyGroup>
            <_DeploymentCopyApplicationManifest>true</_DeploymentCopyApplicationManifest>
        </PropertyGroup>

    </Target>

    <!--
    ============================================================
                                        _DeploymentComputeNativeManifestInfo

    Compute info for native manifest generation
    ============================================================
    -->
    <Target
        Name="_DeploymentComputeNativeManifestInfo"
        Condition="'$(GenerateClickOnceManifests)'!='true'">

        <!-- Create list of items for manifest generation -->
        <ResolveManifestFiles NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)">
            <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependencies"/>
        </ResolveManifestFiles>

        <PropertyGroup>
            <_DeploymentManifestType>Native</_DeploymentManifestType>
        </PropertyGroup>

        <!-- Obtain manifest version from the built assembly -->
        <GetAssemblyIdentity AssemblyFiles="@(IntermediateAssembly)">
            <Output TaskParameter="Assemblies" ItemName="_IntermediateAssemblyIdentity"/>
        </GetAssemblyIdentity>

        <PropertyGroup>
            <_DeploymentManifestVersion>@(_IntermediateAssemblyIdentity->'%(Version)')</_DeploymentManifestVersion>
        </PropertyGroup>

    </Target>

    <!--
    ============================================================
                                        _DeploymentComputeClickOnceManifestInfo

    Compute info for  ClickOnce manifest generation
    ============================================================
    -->
    <Target
        Name="_DeploymentComputeClickOnceManifestInfo"
        Condition="'$(GenerateClickOnceManifests)'=='true'"
        DependsOnTargets="_DeploymentGenerateTrustInfo">

        <!-- Grab just the serialization assemblies for a referenced assembly.  There may also be a symbols file in ReferenceRelatedPaths -->
        <ItemGroup>
            <_SGenDllsRelatedToCurrentDll Include="@(_ReferenceSerializationAssemblyPaths->'%(FullPath)')" Condition="'%(Extension)' == '.dll'"/>
            <_SGenDllsRelatedToCurrentDll Include="@(SerializationAssembly->'%(FullPath)')" Condition="'%(Extension)' == '.dll'"/>
        </ItemGroup>

        <!-- Flag primary dependencies-certain warnings emitted during application manifest generation apply only to them. -->
        <ItemGroup>
            <_DeploymentReferencePaths Include="@(ReferencePath)">
                <IsPrimary>true</IsPrimary>
            </_DeploymentReferencePaths>
        </ItemGroup>

        <!-- Create list of items for manifest generation -->
        <ResolveManifestFiles
            TargetFrameworkVersion="$(TargetFrameworkVersion)"
            SigningManifests="$(SignManifests)"
            EntryPoint="@(_DeploymentManifestEntryPoint)"
            ExtraFiles="@(_DebugSymbolsIntermediatePath);$(IntermediateOutputPath)$(TargetName).xml;@(_ReferenceRelatedPaths)"
            Files="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath)"
            ManagedAssemblies="@(_DeploymentReferencePaths);@(ReferenceDependencyPaths);@(_SGenDllsRelatedToCurrentDll);@(SerializationAssembly)"
            NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)"
            PublishFiles="@(PublishFile)"
            SatelliteAssemblies="@(IntermediateSatelliteAssembliesWithTargetPath);@(ReferenceSatellitePaths)"
            TargetCulture="$(TargetCulture)">

            <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependencies"/>
            <Output TaskParameter="OutputFiles" ItemName="_DeploymentManifestFiles"/>
            <Output TaskParameter="OutputEntryPoint" ItemName="_DeploymentResolvedManifestEntryPoint"/>

        </ResolveManifestFiles>

        <PropertyGroup>
            <_DeploymentManifestType>ClickOnce</_DeploymentManifestType>
        </PropertyGroup>

        <!-- Obtain manifest version from ApplicationVersion and ApplicationRevision properties -->
        <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)">
            <Output TaskParameter="OutputVersion" PropertyName="_DeploymentManifestVersion"/>
        </FormatVersion>

        <FormatUrl InputUrl="$(_DeploymentUrl)">
            <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedDeploymentUrl"/>
        </FormatUrl>

        <FormatUrl InputUrl="$(SupportUrl)">
            <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedSupportUrl"/>
        </FormatUrl>

        <FormatUrl InputUrl="$(ErrorReportUrl)">
            <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedErrorReportUrl"/>
        </FormatUrl>

    </Target>

    <!--
    ============================================================
                                        _DeploymentGenerateTrustInfo

    Generates the application permission set for inclusion in the generated ClickOnce application manifest.
    ============================================================
    -->
    <Target
        Name="_DeploymentGenerateTrustInfo"
        Condition="'$(TargetZone)'!=''"
        Inputs="
            $(MSBuildAllProjects);
            $(_DeploymentBaseManifest);
            "
        Outputs="@(_DeploymentIntermediateTrustInfoFile)">

        <GenerateTrustInfo
            BaseManifest="$(_DeploymentBaseManifest)"
            ApplicationDependencies="@(ReferencePath);@(ReferenceDependencyPaths)"
            ExcludedPermissions="$(ExcludedPermissions)"
            TargetZone="$(TargetZone)"
            TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)">

            <Output TaskParameter="TrustInfoFile" ItemName="FileWrites"/>

        </GenerateTrustInfo>

      </Target>

    <!--
    ============================================================
                                        GenerateDeploymentManifest

    Generates a ClickOnce deployment manifest.
    An deployment manifest specifies declarative application identity and application update information.
    ============================================================
    -->
    <Target
        Name="GenerateDeploymentManifest"
        DependsOnTargets="GenerateApplicationManifest"
        Inputs="
            $(MSBuildAllProjects);
            @(ApplicationManifest)
            "
        Outputs="@(DeployManifest)">

      <GenerateDeploymentManifest
            AssemblyName="$(_DeploymentDeployManifestIdentity)"
            AssemblyVersion="$(_DeploymentManifestVersion)"
            CreateDesktopShortcut="$(CreateDesktopShortcut)"
            DeploymentUrl="$(_DeploymentFormattedDeploymentUrl)"
            Description="$(Description)"
            DisallowUrlActivation="$(DisallowUrlActivation)"
            EntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)"
            ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)"
            Install="$(Install)"
            MapFileExtensions="$(MapFileExtensions)"
            MaxTargetPath="$(MaxTargetPath)"
            MinimumRequiredVersion="$(_DeploymentBuiltMinimumRequiredVersion)"
            OutputManifest="@(DeployManifest)"
            Platform="$(PlatformTarget)"
            Product="$(ProductName)"
            Publisher="$(PublisherName)"
            SuiteName="$(SuiteName)"
            SupportUrl="$(_DeploymentFormattedSupportUrl)"
            TargetCulture="$(TargetCulture)"
            TargetFrameworkVersion="$(TargetFrameworkVersion)"
            TrustUrlParameters="$(TrustUrlParameters)"
            UpdateEnabled="$(UpdateEnabled)"
            UpdateInterval="$(_DeploymentBuiltUpdateInterval)"
            UpdateMode="$(UpdateMode)"
            UpdateUnit="$(_DeploymentBuiltUpdateIntervalUnits)"
            Condition="'$(GenerateClickOnceManifests)'=='true'">

            <Output TaskParameter="OutputManifest" ItemName="FileWrites"/>

        </GenerateDeploymentManifest>

    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareForRun Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        PrepareForRun

    Copy the build outputs to the final directory if they have changed.
    ============================================================
    -->
    <PropertyGroup>
        <PrepareForRunDependsOn>
            CopyFilesToOutputDirectory
        </PrepareForRunDependsOn>
    </PropertyGroup>
    <Target
        Name="PrepareForRun"
        DependsOnTargets="$(PrepareForRunDependsOn)"/>

    <!--
    ============================================================
                                        CopyFilesToOutputDirectory

    Copy all build outputs, satellites and other necessary files to the final directory.
    ============================================================
    -->
    <Target
        Name="CopyFilesToOutputDirectory"
        DependsOnTargets="
            ComputeIntermediateSatelliteAssemblies;
            _CopyFilesMarkedCopyLocal;
            _CopySourceItemsToOutputDirectory;
            _CopyAppConfigFile;
            _CopyManifestFiles;
            _CheckForCompileOutputs;
            _SGenCheckForOutputs">

        <!-- Copy the build product (.dll or .exe). -->
        <Copy
            SourceFiles="@(IntermediateAssembly)"
            DestinationFolder="$(OutDir)"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)">

            <Output TaskParameter="DestinationFiles" ItemName="MainAssembly"/>
            <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

        </Copy>

        <Message Importance="High" Text="$(MSBuildProjectName) -&gt; @(MainAssembly->'%(FullPath)')" />

        <!-- Copy the additional modules. -->
        <Copy
            SourceFiles="@(AddModules)"
            DestinationFolder="$(OutDir)"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)">

            <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

        </Copy>

        <!-- Copy the serialization assembly if it exists. -->
        <Copy
            SourceFiles="$(IntermediateOutputPath)$(_SGenDllName)"
            DestinationFiles="$(OutDir)$(_SGenDllName)"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
            Condition="'$(_SGenDllCreated)'=='true'">

            <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

        </Copy>

        <!-- Copy the debug information file (.pdb), if any -->
        <Copy
            SourceFiles="@(_DebugSymbolsIntermediatePath)"
            DestinationFiles="@(_DebugSymbolsOutputPath)"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
            Condition="'$(_DebugSymbolsProduced)'=='true' and '$(SkipCopyingSymbolsToOutputDirectory)' != 'true'">

            <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

        </Copy>

        <!-- Copy the resulting XML documentation file, if any. -->
        <Copy
            SourceFiles="@(DocFileItem)"
            DestinationFiles="@(FinalDocFile)"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
            Condition="'$(_DocumentationFileProduced)'=='true'">

            <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

        </Copy>

        <!-- Copy satellite assemblies. -->
        <Copy
            SourceFiles="@(IntermediateSatelliteAssembliesWithTargetPath)"
            DestinationFiles="@(IntermediateSatelliteAssembliesWithTargetPath->'$(OutDir)%(Culture)\$(TargetName).resources.dll')"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)">

            <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

        </Copy>

        <!--
        Copy COM reference wrappers, isolated COM references, COM references included by
        native (manifest) references, native (manifest) reference files themselves.
        -->
        <Copy
            SourceFiles="@(ReferenceComWrappersToCopyLocal); @(ResolvedIsolatedComModules); @(_DeploymentLooseManifestFile); @(NativeReferenceFile)"
            DestinationFolder="$(OutDir)"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)">

            <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable"/>

        </Copy>

    </Target>

    <!--
    ============================================================
                                        _CopyFilesMarkedCopyLocal

    Copy references that are marked as "CopyLocal" and their dependencies, including .pdbs, .xmls and satellites.
    ============================================================
    -->
    <Target
        Name="_CopyFilesMarkedCopyLocal">

        <Copy
            SourceFiles="@(ReferenceCopyLocalPaths)"
            DestinationFiles="@(ReferenceCopyLocalPaths->'$(OutDir)%(DestinationSubDirectory)%(Filename)%(Extension)')"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)">

            <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable"/>

        </Copy>

    </Target>

    <!--
    ============================================================
                                        _CopySourceItemsToOutputDirectory
    ============================================================
    -->
    <Target
        Name="_CopySourceItemsToOutputDirectory"
        DependsOnTargets="
            GetCopyToOutputDirectoryItems;
            _CopyOutOfDateSourceItemsToOutputDirectory;
            _CopyOutOfDateSourceItemsToOutputDirectoryAlways"/>


    <!--
    ============================================================
                                        GetCopyToOutputDirectoryItems

    Get all project items that may need to be transferred to the output directory.
    This includes baggage items from transitively referenced projects. It would appear
    that this target computes full transitive closure of content items for all referenced
    projects; however that is not the case. It only collects the content items from its
    immediate children and not children of children. The reason this happens is that
    the NonVCProjectReferences list that is consumed by _SplitProjectReferencesByFileExistence
    is only populated in the current project and is empty in the children. The empty list
    causes _MSBuildProjectReferenceExistent to be empty and terminates the recursion.
    ============================================================
    -->
    <PropertyGroup>
        <GetCopyToOutputDirectoryItemsDependsOn>
            AssignTargetPaths;
            _SplitProjectReferencesByFileExistence
        </GetCopyToOutputDirectoryItemsDependsOn>
    </PropertyGroup>
    <Target
        Name="GetCopyToOutputDirectoryItems"
        Outputs="@(AllItemsFullPathWithTargetPath)" 
        DependsOnTargets="$(GetCopyToOutputDirectoryItemsDependsOn)">

        <!-- Get items from child projects first. -->
        <MSBuild
            Projects="@(_MSBuildProjectReferenceExistent)"
            Targets="GetCopyToOutputDirectoryItems"
            BuildInParallel="$(BuildInParallel)"
            UnloadProjectsOnCompletion="$(UnloadProjectsOnCompletion)"
            Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)"
            Condition="'@(_MSBuildProjectReferenceExistent)' != '' and '$(_GetChildProjectCopyToOutputDirectoryItems)' == 'true' and '%(_MSBuildProjectReferenceExistent.Private)' != 'false'">

            <Output TaskParameter="TargetOutputs" ItemName="_AllChildProjectItemsWithTargetPath"/>

        </MSBuild>

        <!-- Target outputs must be full paths because they will be consumed by a different project. -->
        <ItemGroup>
            <AllItemsFullPathWithTargetPath            Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
            <_SourceItemsToCopyToOutputDirectoryAlways Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
            <_SourceItemsToCopyToOutputDirectory       Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
        </ItemGroup>

        <!-- Get items from this project last so that they will be copied last. -->
        <ItemGroup>
            <AllItemsFullPathWithTargetPath            Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
            <_SourceItemsToCopyToOutputDirectoryAlways Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
            <_SourceItemsToCopyToOutputDirectory       Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
        </ItemGroup>

        <ItemGroup>
            <AllItemsFullPathWithTargetPath            Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' or '%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest'"/>
            <_SourceItemsToCopyToOutputDirectoryAlways Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always'"/>
            <_SourceItemsToCopyToOutputDirectory       Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest'"/>
        </ItemGroup>

        <ItemGroup>
            <_CompileItemsToCopy Include="@(Compile->'%(FullPath)')" Condition="'%(Compile.CopyToOutputDirectory)'=='Always' or '%(Compile.CopyToOutputDirectory)'=='PreserveNewest'"/>
        </ItemGroup>

        <AssignTargetPath Files="@(_CompileItemsToCopy)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="_CompileItemsToCopyWithTargetPath" />
        </AssignTargetPath>

        <ItemGroup>
            <AllItemsFullPathWithTargetPath            Include="@(_CompileItemsToCopyWithTargetPath)"/>
            <_SourceItemsToCopyToOutputDirectoryAlways Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
            <_SourceItemsToCopyToOutputDirectory       Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
        </ItemGroup>

        <ItemGroup>
            <AllItemsFullPathWithTargetPath            Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
            <_SourceItemsToCopyToOutputDirectoryAlways Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
            <_SourceItemsToCopyToOutputDirectory       Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        _CopyOutOfDateSourceItemsToOutputDirectory

    Copy files that have the CopyToOutputDirectory attribute set to 'PreserveNewest'.
    ============================================================
    -->
    <Target
        Name="_CopyOutOfDateSourceItemsToOutputDirectory"
        Condition=" '@(_SourceItemsToCopyToOutputDirectory)' != '' "
        Inputs="@(_SourceItemsToCopyToOutputDirectory)"
        Outputs="@(_SourceItemsToCopyToOutputDirectory->'$(OutDir)%(TargetPath)')">

        <!--
        Not using SkipUnchangedFiles="true" because the application may want to change
        one of these files and not have an incremental build replace it.
        -->
        <Copy
            SourceFiles = "@(_SourceItemsToCopyToOutputDirectory)"
            DestinationFiles = "@(_SourceItemsToCopyToOutputDirectory->'$(OutDir)%(TargetPath)')"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)">

            <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

        </Copy>

    </Target>

    <!--
    ============================================================
                                        _CopyOutOfDateSourceItemsToOutputDirectoryAlways

    Copy files that have the CopyToOutputDirectory attribute set to 'Always'.
    ============================================================
    -->
    <Target
        Name="_CopyOutOfDateSourceItemsToOutputDirectoryAlways"
        Condition=" '@(_SourceItemsToCopyToOutputDirectoryAlways)' != '' ">

        <!--
        Not using SkipUnchangedFiles="true" because the application may want to change
        one of these files and not have an incremental build replace it.
        -->
        <Copy
            SourceFiles = "@(_SourceItemsToCopyToOutputDirectoryAlways)"
            DestinationFiles = "@(_SourceItemsToCopyToOutputDirectoryAlways->'$(OutDir)%(TargetPath)')"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)">

            <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

        </Copy>

    </Target>

    <!--
    ============================================================
                                        _CopyAppConfigFile

    Copy the application config file.
    ============================================================
    -->
    <Target
        Name="_CopyAppConfigFile"
        Condition=" '@(AppConfigWithTargetPath)' != '' "
        Inputs="@(AppConfigWithTargetPath)"
        Outputs="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')">

        <!--
        Copy the application's .config file, if any.
        Not using SkipUnchangedFiles="true" because the application may want to change
        the app.config and not have an incremental build replace it.
        -->
        <Copy
            SourceFiles="@(AppConfigWithTargetPath)"
            DestinationFiles="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)">

            <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

        </Copy>

    </Target>

    <!--
    ================================================================
                                         _CopyManifestFiles
    ================================================================

    Copy the built manifests (.exe.manifest, .application/.xbap) to the final directory.
    -->
    <Target
        Name="_CopyManifestFiles"
        Condition=" '$(_DeploymentCopyApplicationManifest)'=='true' or '$(GenerateClickOnceManifests)'=='true' "
        DependsOnTargets="PrepareForBuild">

        <Copy
            SourceFiles="@(ApplicationManifest)"
            DestinationFolder="$(OutDir)"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
            Condition="'$(GenerateClickOnceManifests)'=='true' or '$(_DeploymentCopyApplicationManifest)'=='true'">

            <Output TaskParameter="DestinationFiles" ItemName="_DeploymentMainApplicationManifest"/>
            <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

        </Copy>

        <Message Importance="Normal" Condition="'$(_DeploymentCopyApplicationManifest)'=='true'" Text="$(MSBuildProjectName) -&gt; @(_DeploymentMainApplicationManifest->'%(FullPath)')" />

        <Copy
            SourceFiles="@(DeployManifest)"
            DestinationFolder="$(OutDir)"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
            Condition="'$(GenerateClickOnceManifests)'=='true'">

            <Output TaskParameter="DestinationFiles" ItemName="_DeploymentMainDeployManifest"/>
            <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

        </Copy>

        <Message Importance="Normal" Condition="'$(GenerateClickOnceManifests)'=='true'" Text="$(MSBuildProjectName) -&gt; @(_DeploymentMainDeployManifest->'%(FullPath)')" />

    </Target>

    <!--
    ================================================================
                                         _CheckForCompileOutputs

    Checks each file output from the main "Compile" target to make sure they really exist.
    If they do, then record them in the clean cache.
    ============================================================
    -->
    <Target
        Name="_CheckForCompileOutputs">

        <!--Record the main compile outputs.-->
        <ItemGroup>
            <FileWrites Include="@(IntermediateAssembly)" Condition="Exists('@(IntermediateAssembly)')"/>
        </ItemGroup>

        <!-- Record the .xml if one was produced. -->
        <PropertyGroup>
            <_DocumentationFileProduced Condition="!Exists('@(DocFileItem)')">false</_DocumentationFileProduced>
        </PropertyGroup>

        <ItemGroup>
            <FileWrites Include="@(DocFileItem)" Condition="'$(_DocumentationFileProduced)'=='true'"/>
        </ItemGroup>

        <!-- Record the .pdb if one was produced. -->
        <PropertyGroup>
            <_DebugSymbolsProduced Condition="!Exists('@(_DebugSymbolsIntermediatePath)')">false</_DebugSymbolsProduced>
        </PropertyGroup>

        <ItemGroup>
            <FileWrites Include="@(_DebugSymbolsIntermediatePath)" Condition="'$(_DebugSymbolsProduced)'=='true'"/>
        </ItemGroup>
    </Target>

    <!--
    ============================================================
                                        _SGenCheckForOutputs

    Checks each file output from the "GenerateSerializationAssemblies" target to make sure they really exist.
    If they do, then record them in the clean cache.
    ============================================================
    -->
    <Target
        Name="_SGenCheckForOutputs"
        Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')"
        >

        <!-- Record the serializer .dll if one was produced.-->
        <PropertyGroup>
            <_SGenDllCreated Condition="Exists('$(IntermediateOutputPath)$(_SGenDllName)')">true</_SGenDllCreated>
        </PropertyGroup>

        <ItemGroup>
            <FileWrites Include="$(IntermediateOutputPath)$(_SGenDllName)" Condition="Exists('$(IntermediateOutputPath)$(_SGenDllName)')"/>
        </ItemGroup>

    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                UnmanagedRegistration Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        UnmanagedRegistration

    Registers the main assembly for COM interop.
    ============================================================
    -->
    <PropertyGroup>
        <UnmanagedRegistrationDependsOn></UnmanagedRegistrationDependsOn>
    </PropertyGroup>
    <Target
        Name="UnmanagedRegistration"
        Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'"
        DependsOnTargets="$(UnmanagedRegistrationDependsOn)"
        >

        <RegisterAssembly
            Assemblies="@(_OutputPathItem->'%(FullPath)$(TargetFileName)')"
            TypeLibFiles="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')"
            AssemblyListFile="@(_UnmanagedRegistrationCache)"
            CreateCodeBase="true"
            Condition="!Exists('@(_UnmanagedRegistrationCache)')"/>

        <ItemGroup>
            <FileWrites Include="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')"/>
        </ItemGroup>
    </Target>





    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                IncrementalClean Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        IncrementalClean

    Remove files that were produced in a prior build but weren't produced in the current build.
    The reason is that if, for example, the name of the .exe has changed we want to delete the
    old copy.

    Leave the Clean cache file containing only the files produced in the current build.
    ============================================================
    -->
    <Target
         Name="IncrementalClean"
         DependsOnTargets="_CleanGetCurrentAndPriorFileWrites">

        <!-- Subtract list of files produced in prior builds from list of files produced in this build. -->
        <ItemGroup>
            <_CleanOrphanFileWrites Include="@(_CleanPriorFileWrites)" Exclude="@(_CleanCurrentFileWrites)"/>
        </ItemGroup>

        <!-- Find all files in the final output directory. -->
        <FindUnderPath Path="$(OutDir)" Files="@(_CleanOrphanFileWrites)">
            <Output TaskParameter="InPath" ItemName="_CleanOrphanFileWritesInOutput"/>
        </FindUnderPath>

        <!-- Find all files in the intermediate output directory. -->
        <FindUnderPath Path="$(IntermediateOutputPath)"    Files="@(_CleanOrphanFileWrites)">
            <Output TaskParameter="InPath" ItemName="_CleanOrphanFileWritesInIntermediate"/>
        </FindUnderPath>

        <!-- Delete the orphaned files. -->
        <Delete
            Files="@(_CleanOrphanFileWritesInIntermediate);@(_CleanOrphanFileWritesInOutput)"
            TreatErrorsAsWarnings="true">

            <Output TaskParameter="DeletedFiles" ItemName="_CleanOrphanFilesDeleted"/>

        </Delete>

        <!-- Create a list of everything that wasn't deleted or was outside
             the current final output and intermediate output directories. -->
        <ItemGroup>
            <_CleanRemainingFileWritesAfterIncrementalClean Include="@(_CleanPriorFileWrites);@(_CleanCurrentFileWrites)" Exclude="@(_CleanOrphanFilesDeleted)"/>
        </ItemGroup>

        <!-- Remove duplicates. -->
        <RemoveDuplicates Inputs="@(_CleanRemainingFileWritesAfterIncrementalClean)">
            <Output TaskParameter="Filtered" ItemName="_CleanUniqueRemainingFileWritesAfterIncrementalClean"/>
        </RemoveDuplicates>

        <!-- Write new list of current files back to disk, replacing the existing list.-->
        <WriteLinesToFile
            File="$(IntermediateOutputPath)$(CleanFile)"
            Lines="@(_CleanUniqueRemainingFileWritesAfterIncrementalClean)"
            Condition="'@(_CleanUnfilteredPriorFileWrites)'!='@(_CleanUniqueRemainingFileWritesAfterIncrementalClean)'"
            Overwrite="true"/>

    </Target>

    <!--
    ============================================================
                                        _CleanGetCurrentAndPriorFileWrites

    Get the list of files built in the current build and in prior builds.
    ============================================================
    -->
    <Target
         Name="_CleanGetCurrentAndPriorFileWrites"
         DependsOnTargets="_CheckForCompileOutputs;_SGenCheckForOutputs">

        <!-- Read the list of files produced by a prior builds from disk. -->
        <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
            <Output TaskParameter="Lines" ItemName="_CleanUnfilteredPriorFileWrites"/>
        </ReadLinesFromFile>

        <!--
        Convert the list of references to the absolute paths so we can make valid comparisons
        across two lists
         -->
        <ConvertToAbsolutePath Paths="@(_ResolveAssemblyReferenceResolvedFiles)">
            <Output TaskParameter="AbsolutePaths" ItemName="_ResolveAssemblyReferenceResolvedFilesAbsolute"/>
        </ConvertToAbsolutePath>

        <!--
        Subtract any resolved assembly files from *prior* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.
         -->
        <ItemGroup>
            <_CleanPriorFileWrites Include="@(_CleanUnfilteredPriorFileWrites)" Exclude="@(_ResolveAssemblyReferenceResolvedFilesAbsolute)"/>
        </ItemGroup>

        <!--
        Of shareable files, keep only those that are in the project's directory.
        We never clean shareable files outside of the project directory because
        the build may be to a common output directory and other projects may need
        them.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
        -->
        <FindUnderPath Path="$(MSBuildProjectDirectory)" Files="@(FileWritesShareable)" UpdateToAbsolutePaths="true">
            <Output TaskParameter="InPath" ItemName="FileWrites"/>
        </FindUnderPath>

        <!-- Find all files in the final output directory. -->
        <FindUnderPath Path="$(OutDir)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
            <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInOutput"/>
        </FindUnderPath>

        <!-- Find all files in the intermediate output directory. -->
        <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
            <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInIntermediate"/>
        </FindUnderPath>

        <!--
        Subtract any resolved assembly files from *current* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
         -->
        <ItemGroup>
            <_CleanCurrentFileWritesWithNoReferences Include="@(_CleanCurrentFileWritesInOutput);@(_CleanCurrentFileWritesInIntermediate)" Exclude="@(_ResolveAssemblyReferenceResolvedFilesAbsolute)"/>
        </ItemGroup>

        <!-- Remove duplicates from files produced in this build. -->
        <RemoveDuplicates Inputs="@(_CleanCurrentFileWritesWithNoReferences)" >
            <Output TaskParameter="Filtered" ItemName="_CleanCurrentFileWrites"/>
        </RemoveDuplicates>

    </Target>

    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Clean Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        Clean

    Delete all intermediate and final build outputs.
    ============================================================
    -->
    <PropertyGroup>
        <CleanDependsOn>
            BeforeClean;
            CleanReferencedProjects;
            UnmanagedUnregistration;
            CoreClean;
            CleanPublishFolder;
            AfterClean
        </CleanDependsOn>
    </PropertyGroup>
    <Target
        Name="Clean"
        Condition=" '$(_InvalidConfigurationWarning)' != 'true' "
        DependsOnTargets="$(CleanDependsOn)" />

    <!--
    ============================================================
                                        BeforeClean

    Redefine this target in your project in order to run tasks just before Clean.
    ============================================================
    -->
    <Target Name="BeforeClean"/>

    <!--
    ============================================================
                                        AfterClean

    Redefine this target in your project in order to run tasks just after Clean.
    ============================================================
    -->
    <Target Name="AfterClean"/>

    <!--
    ============================================================
                                        CleanReferencedProjects

    Call Clean target on all Referenced Projects.
    ============================================================
    -->
    <Target
        Name="CleanReferencedProjects"
        DependsOnTargets="SplitProjectReferencesByType; _SplitProjectReferencesByFileExistence">

        <!--
        When building the project directly from the command-line, clean those referenced projects
        that exist on disk.  For IDE builds and command-line .SLN builds, the solution build manager
        takes care of this.
        -->
        <MSBuild
            Projects="@(_MSBuildProjectReferenceExistent)"
            Targets="Clean"
            BuildInParallel="$(BuildInParallel)"
            UnloadProjectsOnCompletion="$(UnloadProjectsOnCompletion)"
            Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(BuildingSolutionFile)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" />

    </Target>

    <!--
    ============================================================
                                        CoreClean
    ============================================================
    -->
    <PropertyGroup>
        <CoreCleanDependsOn></CoreCleanDependsOn>
    </PropertyGroup>
    <Target
        Name="CoreClean"
        DependsOnTargets="$(CoreCleanDependsOn)">

        <!-- Read in list of files that were written to disk in past builds. -->
        <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
            <Output TaskParameter="Lines" ItemName="_CleanPriorFileWrites"/>
        </ReadLinesFromFile>

        <!-- Find all files in the final output directory. -->
        <FindUnderPath Path="$(OutDir)" Files="@(_CleanPriorFileWrites)">
            <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInOutput"/>
        </FindUnderPath>

        <!-- Find all files in the intermediate output directory. -->
        <FindUnderPath Path="$(IntermediateOutputPath)"    Files="@(_CleanPriorFileWrites)">
            <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInIntermediate"/>
        </FindUnderPath>

        <!-- Delete those files. -->
        <Delete
            Files="@(_CleanPriorFileWritesInOutput);@(_CleanPriorFileWritesInIntermediate)"
            TreatErrorsAsWarnings="true">

            <Output TaskParameter="DeletedFiles" ItemName="_CleanPriorFileWritesDeleted"/>

        </Delete>

        <!-- Create a list of everything that wasn't deleted. -->
        <ItemGroup>
            <_CleanRemainingFileWritesAfterClean Include="@(_CleanPriorFileWrites)" Exclude="@(_CleanPriorFileWritesDeleted)"/>
        </ItemGroup>

        <!-- Remove duplicates. -->
        <RemoveDuplicates Inputs="@(_CleanRemainingFileWritesAfterClean)">
            <Output TaskParameter="Filtered" ItemName="_CleanUniqueRemainingFileWrites"/>
        </RemoveDuplicates>

        <!-- Make sure the directory exists. -->
        <MakeDir Directories="$(IntermediateOutputPath)"/>

        <!-- Write new list of current files back to disk. -->
        <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWrites)" Overwrite="true" />

    </Target>

    <!--
    ============================================================
                                        _CleanRecordFileWrites

    Save the list of all files written to disk so that it can be used for "Clean" later.

    Files written in prior builds are not removed from Clean cache.
    ============================================================
    -->
    <Target
         Name="_CleanRecordFileWrites"
         DependsOnTargets="_CleanGetCurrentAndPriorFileWrites">

        <!--
        Merge list of files from prior builds with the current build and then
        remove duplicates.
        -->
        <RemoveDuplicates Inputs="@(_CleanPriorFileWrites);@(_CleanCurrentFileWrites)">
            <Output TaskParameter="Filtered" ItemName="_CleanUniqueFileWrites"/>
        </RemoveDuplicates>

        <!-- Make sure the directory exists. -->
        <MakeDir Directories="$(IntermediateOutputPath)"/>

        <!-- Write merged file list back to disk, replacing existing contents. -->
        <WriteLinesToFile
            File="$(IntermediateOutputPath)$(CleanFile)"
            Lines="@(_CleanUniqueFileWrites)"
            Overwrite="true" />

    </Target>

    <!--
    ============================================================
                                        CleanPublishFolder
    ============================================================
    -->
    <Target
        Name="CleanPublishFolder">

        <RemoveDir
            Directories="$(PublishDir)"
            Condition="'$(PublishDir)'=='$(OutputPath)app.publish\' and Exists('$(PublishDir)')"/>

    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PostBuildEvent Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        PostBuildEvent

    Run the post-build event. This step is driven by two parameters:

    (1) The $(RunPostBuildEvent) property is set by the user through the IDE and can be one of four values.

        - OnBuildSuccess: In this case, every step of the build must succeed for the post-build step to run.
        - <Blank>: This is the same as OnBuildSuccess.
        - OnOutputUpdated: In this case, the post-build step will run only if the main output assembly was
        actually updated.
        - Always: The post-build step is always run.

    (2) The $(_AssemblyTimestampBeforeCompile) and $(_AssemblyTimestampAfterCompile) values are
        set by the _TimeStampBeforeCompile and _TimeStampAfterCompile targets.  If the assembly was actually
        rebuilt during this build, then the two values will be different.
    ============================================================
    -->
    <PropertyGroup>
        <PostBuildEventDependsOn></PostBuildEventDependsOn>
    </PropertyGroup>
    <Target
        Name="PostBuildEvent"
        Condition=
        "
            '$(PostBuildEvent)'!=''
            and
            (
                '$(RunPostBuildEvent)'!='OnOutputUpdated'
                or
                '$(_AssemblyTimestampBeforeCompile)'!='$(_AssemblyTimestampAfterCompile)'
            )
        "
        DependsOnTargets="$(PostBuildEventDependsOn)">

            <Exec WorkingDirectory="$(OutDir)" Command="$(PostBuildEvent)" />

    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Publish Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        Publish

    This target is only called when doing ClickOnce publishing outside the IDE, which implicitly builds before publishing.
    ============================================================
    -->
    <PropertyGroup>
        <PublishDependsOn Condition="'$(PublishableProject)'=='true'">
            SetGenerateManifests;
            Build;
            PublishOnly
        </PublishDependsOn>
        <PublishDependsOn Condition="'$(PublishableProject)'!='true'">
            _DeploymentUnpublishable
        </PublishDependsOn>
    </PropertyGroup>
    <Target
        Name="Publish"
        DependsOnTargets="$(PublishDependsOn)"/>

    <!--
    ============================================================
                                        _DeploymentUnpublishable

    This target is used to block an attempt to ClickOnce publish a non-publishable project, such as a ClassLibrary, when building outside the IDE.
    ============================================================
    -->
    <Target
        Name="_DeploymentUnpublishable">

        <Message Text="Skipping unpublishable project."/>

    </Target>

    <!--
    ============================================================
                                        SetGenerateManifests

    This target simply assures the GenerateClickOnceManifests property is set whenever the publish target is invoked.
    ============================================================
    -->
    <Target
        Name="SetGenerateManifests">

        <Error Condition="'$(OutputType)'!='winexe' and '$(OutputType)'!='exe'" Text="Publish is only valid for 'Windows Application' or 'Console Application' project types."/>
        <Error Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(ManifestCertificateThumbprint)'=='' and '$(ManifestKeyFile)'==''" Text="A signing key is required in order to publish this project. Please specify a ManifestKeyFile or ManifestCertificateThumbprint value. Publishing from Visual Studio will automatically configure a signing key for this project."/>

        <PropertyGroup>
            <GenerateClickOnceManifests>true</GenerateClickOnceManifests>
        </PropertyGroup>

    </Target>

    <!--
    ============================================================
                                        PublishOnly

    The "PublishOnly" target is intended for ClickOnce publishing inside the IDE, where the build has already been done
    by the BuildManager.
    ============================================================
    -->
    <PropertyGroup>
        <PublishOnlyDependsOn>
            SetGenerateManifests;
            PublishBuild;
            BeforePublish;
            GenerateManifests;
            CopyFilesToOutputDirectory;
            CleanPublishFolder;
            _CopyFilesToPublishFolder;
            _DeploymentGenerateBootstrapper;
            ResolveKeySource;
            _DeploymentSignClickOnceDeployment;
            AfterPublish
        </PublishOnlyDependsOn>
    </PropertyGroup>
    <Target
        Name="PublishOnly"
        DependsOnTargets="$(PublishOnlyDependsOn)"/>

    <!--
    ============================================================
                                        BeforePublish

    Redefine this target in your project in order to run tasks just before Publish.
    ============================================================
    -->
    <Target Name="BeforePublish"/>

    <!--
    ============================================================
                                        AfterPublish

    Redefine this target in your project in order to run tasks just after Publish.
    ============================================================
    -->
    <Target Name="AfterPublish"/>

    <!--
    ============================================================
                                        PublishBuild

    Defines the set of targets that publishing is directly dependent on.
    ============================================================
    -->
    <PropertyGroup>
        <PublishBuildDependsOn>
            BuildOnlySettings;
            PrepareForBuild;
            ResolveReferences;
            PrepareResources;
            ResolveKeySource;
            GenerateSerializationAssemblies;
            CreateSatelliteAssemblies;
        </PublishBuildDependsOn>
    </PropertyGroup>
    <Target
        Name="PublishBuild"
        DependsOnTargets="$(PublishBuildDependsOn)"/>

    <!--
    ============================================================
                                        _CopyFilesToPublishFolder
    ============================================================
    -->
    <Target
        Name="_CopyFilesToPublishFolder">

        <!-- Compute name of application folder, which includes the assembly name plus formatted application version.
             The application version is formatted to use "_" in place of "." chars (i.e. "1_0_0_0" instead of "1.0.0.0").
             This is done because some servers misinterpret "." as a file extension. -->
        <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)" FormatType="Path">
            <Output TaskParameter="OutputVersion" PropertyName="_DeploymentApplicationVersionFragment"/>
        </FormatVersion>

        <PropertyGroup>
            <_DeploymentApplicationFolderName>Application Files\$(AssemblyName)_$(_DeploymentApplicationVersionFragment)</_DeploymentApplicationFolderName>
            <_DeploymentApplicationDir>$(PublishDir)$(_DeploymentApplicationFolderName)\</_DeploymentApplicationDir>
        </PropertyGroup>

        <!-- Copy files to publish folder -->
        <Copy
            SourceFiles=
                "@(_ApplicationManifestFinal);
                @(_DeploymentResolvedManifestEntryPoint);
                @(_DeploymentManifestFiles);
                @(ReferenceComWrappersToCopyLocal);
                @(ResolvedIsolatedComModules);
                @(_DeploymentLooseManifestFile)"
            DestinationFiles=
                "@(_ApplicationManifestFinal->'$(_DeploymentApplicationDir)%(TargetPath)');
                @(_DeploymentManifestEntryPoint->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');
                @(_DeploymentManifestFiles->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');
                @(ReferenceComWrappersToCopyLocal->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)');
                @(ResolvedIsolatedComModules->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)');
                @(_DeploymentLooseManifestFile->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)')"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"/>

        <Copy
            SourceFiles="@(_DeploymentManifestDependencies)"
            DestinationFiles="@(_DeploymentManifestDependencies->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)')"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
            Condition="'%(_DeploymentManifestDependencies.DependencyType)'=='Install'"/>

        <Copy
            SourceFiles="@(_ReferenceScatterPaths)"
            DestinationFiles="@(_ReferenceScatterPaths->'$(_DeploymentApplicationDir)%(Filename)%(Extension)$(_DeploymentFileMappingExtension)')"
            SkipUnchangedFiles="true"
            OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"/>

        <FormatUrl InputUrl="$(_DeploymentApplicationUrl)">
            <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedApplicationUrl"/>
        </FormatUrl>

        <FormatUrl InputUrl="$(_DeploymentComponentsUrl)">
            <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedComponentsUrl"/>
        </FormatUrl>

    </Target>

    <!--
    ============================================================
                                        _DeploymentGenerateBootstrapper
    ============================================================
    -->
    <Target
        Name="_DeploymentGenerateBootstrapper">

        <!-- Build setup.exe bootstrapper and copy referenced packages -->
        <GenerateBootstrapper
            ApplicationFile="$(TargetDeployManifestFileName)"
            ApplicationName="$(AssemblyName)"
            ApplicationUrl="$(_DeploymentFormattedApplicationUrl)"
            BootstrapperItems="@(BootstrapperPackage)"
            ComponentsLocation="$(BootstrapperComponentsLocation)"
            ComponentsUrl="$(_DeploymentFormattedComponentsUrl)"
            Culture="$(TargetCulture)"
            FallbackCulture="$(FallbackCulture)"
            OutputPath="$(PublishDir)"
            SupportUrl="$(_DeploymentFormattedSupportUrl)"
            Path="$(GenerateBootstrapperSdkPath)"
            Condition="'$(BootstrapperEnabled)'=='true'"/>

    </Target>

    <!--
    ============================================================
                                        _DeploymentSignClickOnceDeployment
    ============================================================
    -->
    <Target
        Name="_DeploymentSignClickOnceDeployment">

        <!-- Sign manifests and the bootstrapper -->
        <SignFile
            CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
            TimestampUrl="$(ManifestTimestampUrl)"
            SigningTarget="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)"
            Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />

        <!-- Update entry point path in deploy manifest -->
        <UpdateManifest
            ApplicationPath="$(_DeploymentApplicationFolderName)\$(_DeploymentTargetApplicationManifestFileName)"
            ApplicationManifest="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)"
            InputManifest="$(OutDir)$(TargetDeployManifestFileName)"
            OutputManifest="$(PublishDir)$(TargetDeployManifestFileName)">

            <Output TaskParameter="OutputManifest" ItemName="PublishedDeployManifest"/>

        </UpdateManifest>

        <SignFile
            CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
            TimestampUrl="$(ManifestTimestampUrl)"
            SigningTarget="$(PublishDir)$(TargetDeployManifestFileName)"
            Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />

        <SignFile
            CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
            TimestampUrl="$(ManifestTimestampUrl)"
            SigningTarget="$(PublishDir)\setup.exe"
            Condition="'$(BootstrapperEnabled)'=='true' and '$(_DeploymentSignClickOnceManifests)'=='true'" />


    </Target>




    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                AllProjectOutputGroups Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        AllProjectOutputGroups

    The targets below drive output groups, which provide generic information about a
    project's inputs (e.g., content files, compilation sources, etc.) and built outputs
    (e.g., built EXE/DLL, PDB, XML documentation files, etc.)

    Each target may produce two kinds of items:  outputs and dependencies.  Outputs are
    items from the current project; dependencies are items that are brought into the
    current project as a result of referencing other projects or components.

    For both outputs and dependencies, the Include attribute
    specifies the location of the output/dependency; it must be a full path.  Any number
    of additional attributes may be placed on an output/dependency item.
    ============================================================
    -->
    <Target
        Name="AllProjectOutputGroups"
        DependsOnTargets="
            BuiltProjectOutputGroup;
            DebugSymbolsProjectOutputGroup;
            DocumentationProjectOutputGroup;
            SatelliteDllsProjectOutputGroup;
            SourceFilesProjectOutputGroup;
            ContentFilesProjectOutputGroup;
            SGenFilesOutputGroup"/>

    <!--
    This is the key output for the BuiltProjectOutputGroup and is meant to be read directly from the IDE.
    Reading an item is faster than invoking a target.
    -->
    <ItemGroup>
        <BuiltProjectOutputGroupKeyOutput Include="@(IntermediateAssembly->'%(FullPath)')">
            <IsKeyOutput>true</IsKeyOutput>
            <FinalOutputPath>$(TargetPath)</FinalOutputPath>
            <TargetPath>$(TargetFileName)</TargetPath>
            <COM2REG Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'">true</COM2REG>
        </BuiltProjectOutputGroupKeyOutput>
    </ItemGroup>

    <!--
    ============================================================
                                        BuiltProjectOutputGroup
    ============================================================
    -->
    <PropertyGroup>
        <BuiltProjectOutputGroupDependsOn>PrepareForBuild</BuiltProjectOutputGroupDependsOn>
        <AddAppConfigToBuildOutputs Condition="('$(AddAppConfigToBuildOutputs)'=='') and ('$(OutputType)'!='library')">true</AddAppConfigToBuildOutputs>
    </PropertyGroup>
    <Target
        Name="BuiltProjectOutputGroup"
        Outputs="@(BuiltProjectOutputGroupOutput)"
        DependsOnTargets="$(BuiltProjectOutputGroupDependsOn)">

        <ItemGroup>
            <_BuiltProjectOutputGroupOutputIntermediate Include="@(BuiltProjectOutputGroupKeyOutput)"/>
        </ItemGroup>

        <!-- This item represents the app.config file -->
        <ItemGroup>
            <_BuiltProjectOutputGroupOutputIntermediate Include="$(AppConfig)"  Condition="'$(AddAppConfigToBuildOutputs)'=='true'">
                <FinalOutputPath>$(TargetDir)$(TargetFileName).config</FinalOutputPath>
                <TargetPath>$(TargetFileName).config</TargetPath>
                <!-- For compatibility with 2.0 -->
                <OriginalItemSpec>$(AppConfig)</OriginalItemSpec>
            </_BuiltProjectOutputGroupOutputIntermediate>
        </ItemGroup>

        <ItemGroup>
            <_IsolatedComReference Include="@(COMReference)" Condition=" '%(COMReference.Isolated)' == 'true' "/>
            <_IsolatedComReference Include="@(COMFileReference)" Condition=" '%(COMFileReference.Isolated)' == 'true' "/>
        </ItemGroup>

        <!-- This item represents the native manifest, example: WindowsApplication1.exe.manifest or Native.ClassLibrary1.manifest -->
        <ItemGroup>
            <_BuiltProjectOutputGroupOutputIntermediate Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)" Condition="'@(NativeReference)'!='' or '@(_IsolatedComReference)'!=''">
                <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
                <!-- For compatibility with 2.0 -->
                <OriginalItemSpec>$(OutDir)$(_DeploymentTargetApplicationManifestFileName)</OriginalItemSpec>
            </_BuiltProjectOutputGroupOutputIntermediate>
        </ItemGroup>

        <!-- Convert intermediate items into final items; this way we can get the full path for each item -->
        <ItemGroup>
            <BuiltProjectOutputGroupOutput Include="@(_BuiltProjectOutputGroupOutputIntermediate->'%(FullPath)')">
                <!-- For compatibility with 2.0 -->
                <OriginalItemSpec Condition="'%(_BuiltProjectOutputGroupOutputIntermediate.OriginalItemSpec)' == ''">%(_BuiltProjectOutputGroupOutputIntermediate.FullPath)</OriginalItemSpec>
            </BuiltProjectOutputGroupOutput>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        DebugSymbolsProjectOutputGroup

    This target performs population of the Debug Symbols project output group.
    ============================================================
    -->
    <PropertyGroup>
        <DebugSymbolsProjectOutputGroupDependsOn></DebugSymbolsProjectOutputGroupDependsOn>
    </PropertyGroup>
    <ItemGroup Condition="'$(_DebugSymbolsProduced)'!='false'">
        <DebugSymbolsProjectOutputGroupOutput Include="@(_DebugSymbolsIntermediatePath->'%(FullPath)')">
            <FinalOutputPath>@(_DebugSymbolsOutputPath->'%(FullPath)')</FinalOutputPath>
            <TargetPath>@(_DebugSymbolsIntermediatePath->'%(Filename)%(Extension)')</TargetPath>
        </DebugSymbolsProjectOutputGroupOutput>
    </ItemGroup>
    <Target
        Name="DebugSymbolsProjectOutputGroup"
        Outputs="@(DebugSymbolsProjectOutputGroupOutput)"
        DependsOnTargets="$(DebugSymbolsProjectOutputGroupDependsOn)"/>

    <!--
    ============================================================
                                        DocumentationProjectOutputGroup

    This target performs population of the Documentation project output group.
    ============================================================
    -->
    <PropertyGroup>
        <DocumentationProjectOutputGroupDependsOn></DocumentationProjectOutputGroupDependsOn>
    </PropertyGroup>
    <ItemGroup Condition="'$(DocumentationFile)'!=''">
        <DocumentationProjectOutputGroupOutput Include="@(DocFileItem->'%(FullPath)')">
            <FinalOutputPath>@(FinalDocFile)</FinalOutputPath>
            <IsKeyOutput>true</IsKeyOutput>
            <TargetPath>@(DocFileItem->'%(Filename)%(Extension)')</TargetPath>
        </DocumentationProjectOutputGroupOutput>
    </ItemGroup>
    <Target
        Name="DocumentationProjectOutputGroup"
        Outputs="@(DocumentationProjectOutputGroupOutput)"
        DependsOnTargets="$(DocumentationProjectOutputGroupDependsOn)"/>

    <!--
    ============================================================
                                        SatelliteDllsProjectOutputGroup

    This target performs population of the Satellite Files project output group.
    ============================================================
    -->
    <PropertyGroup>
        <SatelliteDllsProjectOutputGroupDependsOn>PrepareForBuild;PrepareResourceNames</SatelliteDllsProjectOutputGroupDependsOn>
    </PropertyGroup>
    <Target
        Name="SatelliteDllsProjectOutputGroup"
        Outputs="@(SatelliteDllsProjectOutputGroupOutput)"
        DependsOnTargets="$(SatelliteDllsProjectOutputGroupDependsOn)">
        
        <ItemGroup>
            <SatelliteDllsProjectOutputGroupOutputIntermediate Include="$(IntermediateOutputPath)%(EmbeddedResource.Culture)\$(TargetName).resources.dll" 
                                                               Condition="'%(WithCulture)' == 'true'">
                <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
            </SatelliteDllsProjectOutputGroupOutputIntermediate>            
        </ItemGroup>     

        <!-- Convert intermediate items into final items; this way we can get the full path for each item. -->
        <ItemGroup>
            <SatelliteDllsProjectOutputGroupOutput Include="@(SatelliteDllsProjectOutputGroupOutputIntermediate->'%(FullPath)')">
              <!-- For compatibility with 2.0 -->              
                <OriginalItemSpec>%(SatelliteDllsProjectOutputGroupOutputIntermediate.Identity)</OriginalItemSpec>   
            </SatelliteDllsProjectOutputGroupOutput>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        SourceFilesProjectOutputGroup

    This target performs population of the Source Files project output group.
    Source files are items in the project whose type is "Compile" and "EmbeddedResource".
    ============================================================
    -->
    <PropertyGroup>
        <SourceFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</SourceFilesProjectOutputGroupDependsOn>
    </PropertyGroup>
    <Target
        Name="SourceFilesProjectOutputGroup"
        Outputs="@(SourceFilesProjectOutputGroupOutput)"
        DependsOnTargets="$(SourceFilesProjectOutputGroupDependsOn)">

        <AssignTargetPath Files="@(Compile)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="_CompileWithTargetPath" />
        </AssignTargetPath>

        <ItemGroup>
            <!-- First we deal with Compile, EmbeddedResource and AppConfig -->
            <SourceFilesProjectOutputGroupOutput Include="@(_CompileWithTargetPath->'%(FullPath)');@(EmbeddedResource->'%(FullPath)');@(_LicxFile->'%(FullPath)');@(AppConfigWithTargetPath->'%(FullPath)')"/>

            <!-- Include the project file -->
            <SourceFilesProjectOutputGroupOutput Include="$(MSBuildProjectFullPath)">
                <!-- For compatibility with 2.0 -->
                <OriginalItemSpec>$(MSBuildProjectFullPath)</OriginalItemSpec>
                <TargetPath>$(ProjectFileName)</TargetPath>
            </SourceFilesProjectOutputGroupOutput>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        ContentFilesProjectOutputGroup

    This target performs population of the Content Files project output group.
    Content files are items in the project whose type is "Content".
    ============================================================
    -->
    <PropertyGroup>
        <ContentFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</ContentFilesProjectOutputGroupDependsOn>
    </PropertyGroup>
    <Target
        Name="ContentFilesProjectOutputGroup"
        Outputs="@(ContentFilesProjectOutputGroupOutput)"
        DependsOnTargets="$(ContentFilesProjectOutputGroupDependsOn)">

        <!-- Convert items into final items; this way we can get the full path for each item. -->
        <ItemGroup>
            <ContentFilesProjectOutputGroupOutput Include="@(ContentWithTargetPath->'%(FullPath)')"/>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        SGenFilesOutputGroup

    This target performs population of the GenerateSerializationAssemblies Files project output group.
    GenerateSerializationAssemblies files are those generated by the GenerateSerializationAssemblies target and task.
    ============================================================
    -->
    <PropertyGroup>
        <SGenFilesOutputGroupDependsOn></SGenFilesOutputGroupDependsOn>
    </PropertyGroup>
    <ItemGroup
        Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')">
        <SGenFilesOutputGroupOutput Include="@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')">
            <FinalOutputPath>@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')</FinalOutputPath>
            <TargetPath>$(_SGenDllName)</TargetPath>
        </SGenFilesOutputGroupOutput>
    </ItemGroup>
    <Target
        Name="SGenFilesOutputGroup"
        Outputs="@(SGenFilesOutputGroupOutput)"
        DependsOnTargets="$(SGenFilesOutputGroupDependsOn)"/>





    <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                AllProjectOutputGroupsDependencies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->

    <!--
    ============================================================
                                        AllProjectOutputGroupsDependencies
    ============================================================
    -->
    <Target
        Name="AllProjectOutputGroupsDependencies"
        DependsOnTargets="
            BuiltProjectOutputGroupDependencies;
            DebugSymbolsProjectOutputGroupDependencies;
            SatelliteDllsProjectOutputGroupDependencies;
            DocumentationProjectOutputGroupDependencies;
            SGenFilesOutputGroupDependencies"/>

    <!--
    ============================================================
                                        BuiltProjectOutputGroupDependencies

    This target performs population of the Built project output group dependencies.
    ============================================================
    -->
    <Target
        Name="BuiltProjectOutputGroupDependencies"
        DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences"
        Outputs="@(BuiltProjectOutputGroupDependency)">

        <ItemGroup>
            <BuiltProjectOutputGroupDependency  Include="@(ReferencePath->'%(FullPath)');
                                                         @(ReferenceDependencyPaths->'%(FullPath)');
                                                         @(NativeReferenceFile->'%(FullPath)');
                                                         @(_DeploymentLooseManifestFile->'%(FullPath)');
                                                         @(ResolvedIsolatedComModules->'%(FullPath)')"/>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        DebugSymbolsProjectOutputGroupDependencies

    This target performs population of the dependencies for the debug symbols project output group.
    ============================================================
    -->
    <Target
        Name="DebugSymbolsProjectOutputGroupDependencies"
        Condition="'$(DebugSymbols)'!='false'"
        DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences"
        Outputs="@(DebugSymbolsProjectOutputGroupDependency)">

        <!-- This item represents dependent PDB's -->
        <ItemGroup>
            <DebugSymbolsProjectOutputGroupDependency Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pdb'"/>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        SatelliteDllsProjectOutputGroupDependencies

    This target performs population of the dependencies for the satellite files project output group.
    ============================================================
    -->
    <Target
        Name="SatelliteDllsProjectOutputGroupDependencies"
        DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences"
        Outputs="@(SatelliteDllsProjectOutputGroupDependency)">

        <!-- This item represents dependent satellites -->
        <ItemGroup>
            <SatelliteDllsProjectOutputGroupDependency Include="@(ReferenceSatellitePaths->'%(FullPath)')"/>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        DocumentationProjectOutputGroupDependencies

    This target performs population of the dependencies for the documentation project output group.
    ============================================================
    -->
    <Target
        Name="DocumentationProjectOutputGroupDependencies"
        Condition="'$(DocumentationFile)'!=''"
        DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences"
        Outputs="@(DocumentationProjectOutputGroupDependency)">

        <!-- This item represents dependent XMLs -->
        <ItemGroup>
            <DocumentationProjectOutputGroupDependency Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.xml'"/>
        </ItemGroup>

    </Target>

    <!--
    ============================================================
                                        SGenFilesOutputGroupDependencies

    This target performs population of the dependencies for the GenerateSerializationAssemblies project output group.
    ============================================================
    -->
    <Target
        Name="SGenFilesOutputGroupDependencies"
        DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences">

        <!-- This item represents sgen xml serializer dll's -->
        <ItemGroup>
            <SGenFilesOutputGroupDependency Include="@(_ReferenceSerializationAssemblyPaths->'%(FullPath)')" Condition="'%(Extension)' == '.dll'"/>
        </ItemGroup>

    </Target>

    <PropertyGroup>
        <CodeAnalysisTargets Condition="'$(CodeAnalysisTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v9.0\CodeAnalysis\Microsoft.CodeAnalysis.targets</CodeAnalysisTargets>
    </PropertyGroup>

    <Import Project="$(CodeAnalysisTargets)" Condition="Exists('$(CodeAnalysisTargets)')"/>
    <PropertyGroup>
        <RunCodeAnalysisTarget Condition="'$(RunCodeAnalysis)'=='true' and ('$(Language)'=='C#' or '$(Language)'=='VB')">
            RunCodeAnalysis
        </RunCodeAnalysisTarget>
    </PropertyGroup>

    <Import Project="$(ReportingServicesTargets)" Condition="Exists('$(ReportingServicesTargets)')"/>

    <Import Project="Microsoft.WinFX.targets" Condition=" ('$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5') and ('$(TargetCompactFramework)' != 'true') and Exists('$(MSBuildToolsPath)\Microsoft.WinFX.targets')"/>

    <PropertyGroup>
        <MsTestToolsTargets Condition="'$(MsTestToolsTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v9.0\TeamTest\Microsoft.TeamTest.targets</MsTestToolsTargets>
    </PropertyGroup>

    <Import Project="$(MsTestToolsTargets)" Condition="Exists('$(MsTestToolsTargets)')" />

    <Import Project="$(MSBuildToolsPath)\Microsoft.Data.Entity.targets" Condition="'$(TargetFrameworkVersion)'=='v3.5' and Exists('$(MSBuildToolsPath)\Microsoft.Data.Entity.targets')"/>

    <Import Project="$(CustomAfterMicrosoftCommonTargets)" Condition="Exists('$(CustomAfterMicrosoftCommonTargets)')"/>

</Project>
